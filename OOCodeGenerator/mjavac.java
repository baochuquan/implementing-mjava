
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Jul 03 22:03:28 CST 2022
//----------------------------------------------------

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import symtab.*;
import type.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Jul 03 22:03:28 CST 2022
  */
public class mjavac extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public mjavac() {super();}

  /** Constructor which sets the default scanner. */
  public mjavac(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public mjavac(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\365\000\002\002\004\000\002\002\003\000\002\003" +
    "\003\000\002\003\003\000\002\003\003\000\002\003\003" +
    "\000\002\003\003\000\002\003\003\000\002\004\003\000" +
    "\002\004\003\000\002\005\003\000\002\005\003\000\002" +
    "\006\003\000\002\006\003\000\002\006\003\000\002\007" +
    "\003\000\002\007\003\000\002\010\004\000\002\010\004" +
    "\000\002\011\003\000\002\011\005\000\002\017\002\000" +
    "\002\017\003\000\002\013\002\000\002\013\004\000\002" +
    "\132\002\000\002\013\005\000\002\133\002\000\002\014" +
    "\007\000\002\134\002\000\002\014\011\000\002\015\005" +
    "\000\002\021\002\000\002\021\003\000\002\020\003\000" +
    "\002\020\004\000\002\022\003\000\002\022\003\000\002" +
    "\022\003\000\002\023\003\000\002\023\003\000\002\023" +
    "\003\000\002\024\006\000\002\135\002\000\002\024\007" +
    "\000\002\136\002\000\002\024\007\000\002\025\003\000" +
    "\002\025\006\000\002\137\002\000\002\025\006\000\002" +
    "\012\002\000\002\026\003\000\002\026\005\000\002\027" +
    "\004\000\002\140\002\000\002\031\011\000\002\141\002" +
    "\000\002\031\011\000\002\142\002\000\002\031\007\000" +
    "\002\032\002\000\002\032\003\000\002\033\003\000\002" +
    "\033\005\000\002\143\002\000\002\033\005\000\002\034" +
    "\004\000\002\035\006\000\002\035\006\000\002\035\003" +
    "\000\002\030\002\000\002\036\004\000\002\144\002\000" +
    "\002\037\010\000\002\040\007\000\002\040\006\000\002" +
    "\040\006\000\002\043\002\000\002\041\007\000\002\041" +
    "\007\000\002\041\011\000\002\041\011\000\002\042\006" +
    "\000\002\145\002\000\002\042\007\000\002\044\002\000" +
    "\002\044\003\000\002\045\003\000\002\045\004\000\002" +
    "\146\002\000\002\045\005\000\002\046\003\000\002\046" +
    "\003\000\002\047\005\000\002\147\002\000\002\047\006" +
    "\000\002\050\003\000\002\050\003\000\002\050\003\000" +
    "\002\050\003\000\002\051\003\000\002\051\003\000\002" +
    "\051\003\000\002\052\003\000\002\052\003\000\002\052" +
    "\003\000\002\052\003\000\002\053\003\000\002\054\004" +
    "\000\002\055\003\000\002\055\003\000\002\055\003\000" +
    "\002\076\002\000\002\077\002\000\002\100\002\000\002" +
    "\101\002\000\002\056\011\000\002\150\002\000\002\056" +
    "\010\000\002\057\014\000\002\151\002\000\002\057\014" +
    "\000\002\060\014\000\002\061\011\000\002\152\002\000" +
    "\002\061\010\000\002\062\011\000\002\110\002\000\002" +
    "\063\006\000\002\064\003\000\002\064\003\000\002\105" +
    "\002\000\002\065\003\000\002\065\003\000\002\065\006" +
    "\000\002\065\003\000\002\065\003\000\002\065\003\000" +
    "\002\065\003\000\002\065\005\000\002\065\005\000\002" +
    "\065\005\000\002\065\005\000\002\065\005\000\002\153" +
    "\002\000\002\065\007\000\002\154\002\000\002\065\006" +
    "\000\002\155\002\000\002\066\011\000\002\016\002\000" +
    "\002\016\003\000\002\067\002\000\002\067\003\000\002" +
    "\070\003\000\002\070\005\000\002\156\002\000\002\070" +
    "\005\000\002\071\006\000\002\071\006\000\002\072\003" +
    "\000\002\072\004\000\002\157\002\000\002\072\005\000" +
    "\002\073\005\000\002\074\002\000\002\074\003\000\002" +
    "\075\004\000\002\075\005\000\002\111\005\000\002\111" +
    "\005\000\002\112\006\000\002\112\010\000\002\112\010" +
    "\000\002\113\006\000\002\113\006\000\002\114\003\000" +
    "\002\114\003\000\002\114\004\000\002\104\002\000\002" +
    "\115\003\000\002\115\005\000\002\115\004\000\002\115" +
    "\004\000\002\116\003\000\002\116\005\000\002\116\005" +
    "\000\002\116\005\000\002\160\002\000\002\116\006\000" +
    "\002\161\002\000\002\116\006\000\002\162\002\000\002" +
    "\116\006\000\002\117\003\000\002\117\005\000\002\117" +
    "\005\000\002\120\003\000\002\120\005\000\002\120\005" +
    "\000\002\120\005\000\002\120\005\000\002\163\002\000" +
    "\002\120\006\000\002\164\002\000\002\120\006\000\002" +
    "\165\002\000\002\120\006\000\002\166\002\000\002\120" +
    "\006\000\002\121\003\000\002\121\005\000\002\121\005" +
    "\000\002\167\002\000\002\121\006\000\002\170\002\000" +
    "\002\121\006\000\002\102\002\000\002\122\003\000\002" +
    "\122\006\000\002\171\002\000\002\122\006\000\002\103" +
    "\002\000\002\123\003\000\002\123\006\000\002\172\002" +
    "\000\002\123\006\000\002\106\002\000\002\107\002\000" +
    "\002\124\003\000\002\124\011\000\002\173\002\000\002" +
    "\124\010\000\002\125\003\000\002\125\003\000\002\126" +
    "\006\000\002\174\002\000\002\126\006\000\002\127\003" +
    "\000\002\127\003\000\002\127\003\000\002\130\002\000" +
    "\002\130\003\000\002\131\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01c9\000\012\002\uffea\003\005\024\uffea\025\uffea\001" +
    "\002\000\004\002\u01cb\001\002\000\006\024\uffe8\025\uffe8" +
    "\001\002\000\010\002\000\024\010\025\uffec\001\002\000" +
    "\004\025\012\001\002\000\020\004\uffeb\005\uffeb\006\uffeb" +
    "\007\uffeb\025\uffeb\027\uffeb\064\uffeb\001\002\000\010\002" +
    "\uffe9\024\uffe9\025\uffe9\001\002\000\004\064\013\001\002" +
    "\000\006\016\uffe6\026\014\001\002\000\004\064\u01c6\001" +
    "\002\000\004\016\016\001\002\000\030\003\027\004\uffec" +
    "\005\uffec\006\uffec\007\uffec\013\030\016\020\017\uffe1\024" +
    "\010\027\uffec\064\uffec\001\002\000\010\002\uffe5\024\uffe5" +
    "\025\uffe5\001\002\000\060\003\uffb3\004\uffb3\005\uffb3\006" +
    "\uffb3\007\uffb3\013\uffb3\016\uffb3\017\uffb3\021\uffb3\027\uffb3" +
    "\030\uffb3\031\uffb3\033\uffb3\035\uffb3\036\uffb3\037\uffb3\057" +
    "\uffb3\060\uffb3\061\uffb3\062\uffb3\063\uffb3\064\uffb3\065\uffb3" +
    "\001\002\000\006\013\u01ba\016\u01b9\001\002\000\030\003" +
    "\uffdc\004\uffdc\005\uffdc\006\uffdc\007\uffdc\013\uffdc\016\uffdc" +
    "\017\uffdc\024\uffdc\027\uffdc\064\uffdc\001\002\000\030\003" +
    "\uffdb\004\uffdb\005\uffdb\006\uffdb\007\uffdb\013\uffdb\016\uffdb" +
    "\017\uffdb\024\uffdb\027\uffdb\064\uffdb\001\002\000\030\003" +
    "\uffd9\004\uffd9\005\uffd9\006\uffd9\007\uffd9\013\uffd9\016\uffd9" +
    "\017\uffd9\024\uffd9\027\uffd9\064\uffd9\001\002\000\030\003" +
    "\027\004\uffec\005\uffec\006\uffec\007\uffec\013\030\016\020" +
    "\017\uffe0\024\010\027\uffec\064\uffec\001\002\000\004\016" +
    "\143\001\002\000\004\021\uffc6\001\002\000\030\003\uffd8" +
    "\004\uffd8\005\uffd8\006\uffd8\007\uffd8\013\uffd8\016\uffd8\017" +
    "\uffd8\024\uffd8\027\uffd8\064\uffd8\001\002\000\030\003\uffdf" +
    "\004\uffdf\005\uffdf\006\uffdf\007\uffdf\013\uffdf\016\uffdf\017" +
    "\uffdf\024\uffdf\027\uffdf\064\uffdf\001\002\000\030\003\uffda" +
    "\004\uffda\005\uffda\006\uffda\007\uffda\013\uffda\016\uffda\017" +
    "\uffda\024\uffda\027\uffda\064\uffda\001\002\000\030\003\uffdd" +
    "\004\uffdd\005\uffdd\006\uffdd\007\uffdd\013\uffdd\016\uffdd\017" +
    "\uffdd\024\uffdd\027\uffdd\064\uffdd\001\002\000\016\004\041" +
    "\005\037\006\052\007\051\027\042\064\046\001\002\000" +
    "\004\017\036\001\002\000\062\002\uffe2\010\uffe2\011\uffe2" +
    "\012\uffe2\013\uffe2\014\uffe2\015\uffe2\022\uffe2\023\uffe2\024" +
    "\uffe2\025\uffe2\040\uffe2\041\uffe2\043\uffe2\044\uffe2\045\uffe2" +
    "\046\uffe2\047\uffe2\050\uffe2\051\uffe2\052\uffe2\053\uffe2\054" +
    "\uffe2\055\uffe2\001\002\000\012\003\ufff5\010\ufff5\012\ufff5" +
    "\064\ufff5\001\002\000\012\003\ufff2\010\122\012\135\064" +
    "\ufff2\001\002\000\012\003\ufff6\010\ufff6\012\ufff6\064\ufff6" +
    "\001\002\000\004\064\127\001\002\000\010\003\ufff9\010" +
    "\122\064\ufff9\001\002\000\012\003\ufff7\010\ufff7\012\ufff7" +
    "\064\ufff7\001\002\000\006\003\075\064\076\001\002\000" +
    "\014\003\uffee\010\uffee\012\uffee\021\uffb8\064\uffee\001\002" +
    "\000\006\003\ufff8\064\ufff8\001\002\000\006\003\ufff1\064" +
    "\ufff1\001\002\000\012\003\ufff3\010\ufff3\012\ufff3\064\ufff3" +
    "\001\002\000\012\003\ufff4\010\ufff4\012\ufff4\064\ufff4\001" +
    "\002\000\004\021\054\001\002\000\020\003\060\004\041" +
    "\005\037\006\052\007\051\022\uffc4\064\062\001\002\000" +
    "\004\022\073\001\002\000\006\015\071\022\uffc3\001\002" +
    "\000\006\015\uffc2\022\uffc2\001\002\000\014\004\uffc0\005" +
    "\uffc0\006\uffc0\007\uffc0\064\uffc0\001\002\000\004\064\064" +
    "\001\002\000\064\003\uffee\010\uffee\011\uffee\012\uffee\013" +
    "\uffee\014\uffee\015\uffee\020\uffee\021\uffee\022\uffee\023\uffee" +
    "\040\uffee\041\uffee\043\uffee\044\uffee\045\uffee\046\uffee\047" +
    "\uffee\050\uffee\051\uffee\052\uffee\053\uffee\054\uffee\055\uffee" +
    "\064\uffee\001\002\000\010\010\065\015\uffbe\022\uffbe\001" +
    "\002\000\012\010\uffcd\013\uffcd\015\uffcd\022\uffcd\001\002" +
    "\000\004\011\066\001\002\000\012\010\uffcc\013\uffcc\015" +
    "\uffcc\022\uffcc\001\002\000\014\004\041\005\037\006\052" +
    "\007\051\064\062\001\002\000\006\015\uffbf\022\uffbf\001" +
    "\002\000\014\004\041\005\037\006\052\007\051\064\062" +
    "\001\002\000\006\015\uffc1\022\uffc1\001\002\000\004\016" +
    "\uffb7\001\002\000\010\010\065\013\uffd2\015\uffd2\001\002" +
    "\000\026\003\uffd4\004\uffd4\005\uffd4\006\uffd4\007\uffd4\013" +
    "\uffd6\015\uffd0\024\uffd4\027\uffd4\064\uffd4\001\002\000\012" +
    "\010\uffcd\013\uffcd\015\uffcd\021\uffca\001\002\000\006\013" +
    "\101\015\100\001\002\000\004\064\uffce\001\002\000\030" +
    "\003\uffd7\004\uffd7\005\uffd7\006\uffd7\007\uffd7\013\uffd7\016" +
    "\uffd7\017\uffd7\024\uffd7\027\uffd7\064\uffd7\001\002\000\004" +
    "\064\064\001\002\000\010\010\065\013\uffd1\015\uffd1\001" +
    "\002\000\004\021\105\001\002\000\020\003\060\004\041" +
    "\005\037\006\052\007\051\022\uffc4\064\062\001\002\000" +
    "\004\022\107\001\002\000\006\013\uffc9\016\uffc9\001\002" +
    "\000\004\013\121\001\002\000\004\015\117\001\002\000" +
    "\022\003\027\004\uffec\005\uffec\006\uffec\007\uffec\024\010" +
    "\027\uffec\064\uffec\001\002\000\016\004\041\005\037\006" +
    "\052\007\051\027\042\064\062\001\002\000\030\003\uffd3" +
    "\004\uffd3\005\uffd3\006\uffd3\007\uffd3\013\uffd3\016\uffd3\017" +
    "\uffd3\024\uffd3\027\uffd3\064\uffd3\001\002\000\004\064\116" +
    "\001\002\000\004\021\uffca\001\002\000\004\064\064\001" +
    "\002\000\010\010\065\013\uffcf\015\uffcf\001\002\000\030" +
    "\003\uffd5\004\uffd5\005\uffd5\006\uffd5\007\uffd5\013\uffd5\016" +
    "\uffd5\017\uffd5\024\uffd5\027\uffd5\064\uffd5\001\002\000\004" +
    "\011\126\001\002\000\012\003\ufff0\010\124\012\ufff0\064" +
    "\ufff0\001\002\000\004\011\125\001\002\000\060\003\uff58" +
    "\010\uff58\011\uff58\012\uff58\013\uff58\014\uff58\015\uff58\022" +
    "\uff58\023\uff58\040\uff58\041\uff58\043\uff58\044\uff58\045\uff58" +
    "\046\uff58\047\uff58\050\uff58\051\uff58\052\uff58\053\uff58\054" +
    "\uff58\055\uff58\064\uff58\001\002\000\060\003\uff59\010\uff59" +
    "\011\uff59\012\uff59\013\uff59\014\uff59\015\uff59\022\uff59\023" +
    "\uff59\040\uff59\041\uff59\043\uff59\044\uff59\045\uff59\046\uff59" +
    "\047\uff59\050\uff59\051\uff59\052\uff59\053\uff59\054\uff59\055" +
    "\uff59\064\uff59\001\002\000\004\021\uffc8\001\002\000\004" +
    "\021\131\001\002\000\020\003\060\004\041\005\037\006" +
    "\052\007\051\022\uffc4\064\062\001\002\000\004\022\133" +
    "\001\002\000\006\013\uffc7\016\uffc7\001\002\000\012\003" +
    "\uffef\010\124\012\uffef\064\uffef\001\002\000\004\064\136" +
    "\001\002\000\064\003\uffed\010\uffed\011\uffed\012\uffed\013" +
    "\uffed\014\uffed\015\uffed\020\uffed\021\uffed\022\uffed\023\uffed" +
    "\040\uffed\041\uffed\043\uffed\044\uffed\045\uffed\046\uffed\047" +
    "\uffed\050\uffed\051\uffed\052\uffed\053\uffed\054\uffed\055\uffed" +
    "\064\uffed\001\002\000\004\021\140\001\002\000\020\003" +
    "\060\004\041\005\037\006\052\007\051\022\uffc4\064\062" +
    "\001\002\000\004\022\142\001\002\000\006\013\uffc5\016" +
    "\uffc5\001\002\000\060\003\uffba\004\uffba\005\uffba\006\uffba" +
    "\007\uffba\013\uffba\016\uffba\017\uffba\021\uffba\027\uffba\030" +
    "\uffba\031\uffba\033\uffba\035\uffba\036\uffba\037\uffba\057\uffba" +
    "\060\uffba\061\uffba\062\uffba\063\uffba\064\uffba\065\uffba\001" +
    "\002\000\030\003\uffb9\004\uffb9\005\uffb9\006\uffb9\007\uffb9" +
    "\013\uffb9\016\uffb9\017\uffb9\024\uffb9\027\uffb9\064\uffb9\001" +
    "\002\000\060\003\200\004\041\005\037\006\052\007\051" +
    "\013\163\016\020\017\uffab\021\153\027\202\030\172\031" +
    "\176\033\171\035\211\036\175\037\177\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\004\013\u01b6\001\002\000\056\010\uff78\011\uff78\012\uff78" +
    "\013\uff78\014\uff78\015\uff78\020\uff11\022\uff78\023\uff78\040" +
    "\uff78\041\uff78\043\uff78\044\uff78\045\uff78\046\uff78\047\uff78" +
    "\050\uff78\051\uff78\052\uff78\053\uff78\054\uff78\055\uff78\001" +
    "\002\000\054\010\ufffb\011\ufffb\012\ufffb\013\ufffb\014\ufffb" +
    "\015\ufffb\022\ufffb\023\ufffb\040\ufffb\041\ufffb\043\ufffb\044" +
    "\ufffb\045\ufffb\046\ufffb\047\ufffb\050\ufffb\051\ufffb\052\ufffb" +
    "\053\ufffb\054\ufffb\055\ufffb\001\002\000\060\003\uff9f\004" +
    "\uff9f\005\uff9f\006\uff9f\007\uff9f\013\uff9f\016\uff9f\017\uff9f" +
    "\021\uff9f\027\uff9f\030\uff9f\031\uff9f\033\uff9f\035\uff9f\036" +
    "\uff9f\037\uff9f\057\uff9f\060\uff9f\061\uff9f\062\uff9f\063\uff9f" +
    "\064\uff9f\065\uff9f\001\002\000\004\020\u01b3\001\002\000" +
    "\054\003\uff7d\004\uff7d\005\uff7d\006\uff7d\007\uff7d\021\uff7d" +
    "\027\uff7d\030\uff7d\031\uff7d\032\uff7d\037\uff7d\040\uff7d\041" +
    "\uff7d\042\uff7d\057\uff7d\060\uff7d\061\uff7d\062\uff7d\063\uff7d" +
    "\064\uff7d\065\uff7d\001\002\000\054\010\uff7c\011\uff7c\012" +
    "\uff7c\013\uff7c\014\uff7c\015\uff7c\022\uff7c\023\uff7c\040\uff7c" +
    "\041\uff7c\043\uff7c\044\uff7c\045\uff7c\046\uff7c\047\uff7c\050" +
    "\uff7c\051\uff7c\052\uff7c\053\uff7c\054\uff7c\055\uff7c\001\002" +
    "\000\052\011\uff7e\012\uff7e\013\uff7e\014\uff7e\015\uff7e\022" +
    "\uff7e\023\uff7e\040\uff7e\041\uff7e\043\uff7e\044\uff7e\045\uff7e" +
    "\046\uff7e\047\uff7e\050\uff7e\051\uff7e\052\uff7e\053\uff7e\054" +
    "\uff7e\055\uff7e\001\002\000\062\003\uff99\004\uff99\005\uff99" +
    "\006\uff99\007\uff99\013\uff99\016\uff99\017\uff99\021\uff99\027" +
    "\uff99\030\uff99\031\uff99\033\uff99\034\uff99\035\uff99\036\uff99" +
    "\037\uff99\057\uff99\060\uff99\061\uff99\062\uff99\063\uff99\064" +
    "\uff99\065\uff99\001\002\000\060\003\u01ab\004\041\005\037" +
    "\006\052\007\051\013\163\016\020\017\uffab\021\153\027" +
    "\202\030\231\031\232\033\171\035\211\036\175\037\177" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\016\003\ufff2\010\313\012\315\020\uff12" +
    "\021\314\064\ufff2\001\002\000\054\010\ufffd\011\ufffd\012" +
    "\ufffd\013\ufffd\014\ufffd\015\ufffd\022\ufffd\023\ufffd\040\ufffd" +
    "\041\ufffd\043\ufffd\044\ufffd\045\ufffd\046\ufffd\047\ufffd\050" +
    "\ufffd\051\ufffd\052\ufffd\053\ufffd\054\ufffd\055\ufffd\001\002" +
    "\000\054\010\ufffc\011\ufffc\012\ufffc\013\ufffc\014\ufffc\015" +
    "\ufffc\022\ufffc\023\ufffc\040\ufffc\041\ufffc\043\ufffc\044\ufffc" +
    "\045\ufffc\046\ufffc\047\ufffc\050\ufffc\051\ufffc\052\ufffc\053" +
    "\ufffc\054\ufffc\055\ufffc\001\002\000\062\003\uff95\004\uff95" +
    "\005\uff95\006\uff95\007\uff95\013\uff95\016\uff95\017\uff95\021" +
    "\uff95\027\uff95\030\uff95\031\uff95\033\uff95\034\uff95\035\uff95" +
    "\036\uff95\037\uff95\057\uff95\060\uff95\061\uff95\062\uff95\063" +
    "\uff95\064\uff95\065\uff95\001\002\000\062\003\uff98\004\uff98" +
    "\005\uff98\006\uff98\007\uff98\013\uff98\016\uff98\017\uff98\021" +
    "\uff98\027\uff98\030\uff98\031\uff98\033\uff98\034\uff98\035\uff98" +
    "\036\uff98\037\uff98\057\uff98\060\uff98\061\uff98\062\uff98\063" +
    "\uff98\064\uff98\065\uff98\001\002\000\010\003\ufff1\012\u0124" +
    "\064\ufff1\001\002\000\004\013\uff93\001\002\000\004\012" +
    "\u019f\001\002\000\054\010\ufffa\011\ufffa\012\ufffa\013\ufffa" +
    "\014\ufffa\015\ufffa\022\ufffa\023\ufffa\040\ufffa\041\ufffa\043" +
    "\ufffa\044\ufffa\045\ufffa\046\ufffa\047\ufffa\050\ufffa\051\ufffa" +
    "\052\ufffa\053\ufffa\054\ufffa\055\ufffa\001\002\000\006\003" +
    "\u0165\021\u0166\001\002\000\010\010\uff7b\012\uff7b\021\u0161" +
    "\001\002\000\004\017\u0160\001\002\000\060\003\uffa4\004" +
    "\uffa4\005\uffa4\006\uffa4\007\uffa4\013\uffa4\016\uffa4\017\uffa4" +
    "\021\uffa4\027\uffa4\030\uffa4\031\uffa4\033\uffa4\035\uffa4\036" +
    "\uffa4\037\uffa4\057\uffa4\060\uffa4\061\uffa4\062\uffa4\063\uffa4" +
    "\064\uffa4\065\uffa4\001\002\000\056\003\uff81\004\uff81\005" +
    "\uff81\006\uff81\007\uff81\013\uff81\021\uff81\027\uff81\030\uff81" +
    "\031\uff81\032\uff81\037\uff81\040\uff81\041\uff81\042\uff81\057" +
    "\uff81\060\uff81\061\uff81\062\uff81\063\uff81\064\uff81\065\uff81" +
    "\001\002\000\006\012\u0129\021\u0158\001\002\000\014\004" +
    "\041\005\037\006\052\007\051\064\062\001\002\000\064" +
    "\003\uffa7\004\uffa7\005\uffa7\006\uffa7\007\uffa7\012\uff6e\013" +
    "\uffa7\016\uffa7\017\u013f\020\uff14\021\uffa7\027\uffa7\030\uffa7" +
    "\031\uffa7\033\uffa7\035\uffa7\036\uffa7\037\uffa7\057\uffa7\060" +
    "\uffa7\061\uffa7\062\uffa7\063\uffa7\064\uffa7\065\uffa7\001\002" +
    "\000\062\003\uff96\004\uff96\005\uff96\006\uff96\007\uff96\013" +
    "\uff96\016\uff96\017\uff96\021\uff96\027\uff96\030\uff96\031\uff96" +
    "\033\uff96\034\uff96\035\uff96\036\uff96\037\uff96\057\uff96\060" +
    "\uff96\061\uff96\062\uff96\063\uff96\064\uff96\065\uff96\001\002" +
    "\000\004\012\u013d\001\002\000\012\003\ufff9\010\122\012" +
    "\u011c\064\ufff9\001\002\000\010\010\uff79\012\uff79\013\uff91" +
    "\001\002\000\054\010\ufffe\011\ufffe\012\ufffe\013\ufffe\014" +
    "\ufffe\015\ufffe\022\ufffe\023\ufffe\040\ufffe\041\ufffe\043\ufffe" +
    "\044\ufffe\045\ufffe\046\ufffe\047\ufffe\050\ufffe\051\ufffe\052" +
    "\ufffe\053\ufffe\054\ufffe\055\ufffe\001\002\000\054\010\u013a" +
    "\011\uff7f\012\uff7f\013\uff7f\014\uff7f\015\uff7f\022\uff7f\023" +
    "\uff7f\040\uff7f\041\uff7f\043\uff7f\044\uff7f\045\uff7f\046\uff7f" +
    "\047\uff7f\050\uff7f\051\uff7f\052\uff7f\053\uff7f\054\uff7f\055" +
    "\uff7f\001\002\000\010\010\uff77\012\uff77\013\uff92\001\002" +
    "\000\060\003\uff9d\004\uff9d\005\uff9d\006\uff9d\007\uff9d\013" +
    "\uff9d\016\uff9d\017\uff9d\021\uff9d\027\uff9d\030\uff9d\031\uff9d" +
    "\033\uff9d\035\uff9d\036\uff9d\037\uff9d\057\uff9d\060\uff9d\061" +
    "\uff9d\062\uff9d\063\uff9d\064\uff9d\065\uff9d\001\002\000\006" +
    "\003\u012e\021\u012f\001\002\000\060\003\uffa5\004\uffa5\005" +
    "\uffa5\006\uffa5\007\uffa5\013\uffa5\016\uffa5\017\uffa5\021\uffa5" +
    "\027\uffa5\030\uffa5\031\uffa5\033\uffa5\035\uffa5\036\uffa5\037" +
    "\uffa5\057\uffa5\060\uffa5\061\uffa5\062\uffa5\063\uffa5\064\uffa5" +
    "\065\uffa5\001\002\000\060\003\uffa9\004\uffa9\005\uffa9\006" +
    "\uffa9\007\uffa9\013\uffa9\016\uffa9\017\uffa9\021\uffa9\027\uffa9" +
    "\030\uffa9\031\uffa9\033\uffa9\035\uffa9\036\uffa9\037\uffa9\057" +
    "\uffa9\060\uffa9\061\uffa9\062\uffa9\063\uffa9\064\uffa9\065\uffa9" +
    "\001\002\000\060\003\uffa0\004\uffa0\005\uffa0\006\uffa0\007" +
    "\uffa0\013\uffa0\016\uffa0\017\uffa0\021\uffa0\027\uffa0\030\uffa0" +
    "\031\uffa0\033\uffa0\035\uffa0\036\uffa0\037\uffa0\057\uffa0\060" +
    "\uffa0\061\uffa0\062\uffa0\063\uffa0\064\uffa0\065\uffa0\001\002" +
    "\000\062\003\uff97\004\uff97\005\uff97\006\uff97\007\uff97\013" +
    "\uff97\016\uff97\017\uff97\021\uff97\027\uff97\030\uff97\031\uff97" +
    "\033\uff97\034\uff97\035\uff97\036\uff97\037\uff97\057\uff97\060" +
    "\uff97\061\uff97\062\uff97\063\uff97\064\uff97\065\uff97\001\002" +
    "\000\060\003\233\004\041\005\037\006\052\007\051\013" +
    "\163\016\020\017\uffaa\021\153\027\202\030\231\031\232" +
    "\033\171\035\211\036\175\037\177\057\221\060\205\061" +
    "\161\062\162\063\150\064\062\065\170\001\002\000\060" +
    "\003\uff9e\004\uff9e\005\uff9e\006\uff9e\007\uff9e\013\uff9e\016" +
    "\uff9e\017\uff9e\021\uff9e\027\uff9e\030\uff9e\031\uff9e\033\uff9e" +
    "\035\uff9e\036\uff9e\037\uff9e\057\uff9e\060\uff9e\061\uff9e\062" +
    "\uff9e\063\uff9e\064\uff9e\065\uff9e\001\002\000\056\010\uff76" +
    "\011\uff76\012\uff76\013\uff76\014\uff76\015\uff76\020\uff10\022" +
    "\uff76\023\uff76\040\uff76\041\uff76\043\uff76\044\uff76\045\uff76" +
    "\046\uff76\047\uff76\050\uff76\051\uff76\052\uff76\053\uff76\054" +
    "\uff76\055\uff76\001\002\000\054\010\uffff\011\uffff\012\uffff" +
    "\013\uffff\014\uffff\015\uffff\022\uffff\023\uffff\040\uffff\041" +
    "\uffff\043\uffff\044\uffff\045\uffff\046\uffff\047\uffff\050\uffff" +
    "\051\uffff\052\uffff\053\uffff\054\uffff\055\uffff\001\002\000" +
    "\006\003\223\064\064\001\002\000\006\013\uffa2\015\uffd0" +
    "\001\002\000\006\013\225\015\100\001\002\000\060\003" +
    "\uffa3\004\uffa3\005\uffa3\006\uffa3\007\uffa3\013\uffa3\016\uffa3" +
    "\017\uffa3\021\uffa3\027\uffa3\030\uffa3\031\uffa3\033\uffa3\035" +
    "\uffa3\036\uffa3\037\uffa3\057\uffa3\060\uffa3\061\uffa3\062\uffa3" +
    "\063\uffa3\064\uffa3\065\uffa3\001\002\000\004\013\227\001" +
    "\002\000\060\003\uffa1\004\uffa1\005\uffa1\006\uffa1\007\uffa1" +
    "\013\uffa1\016\uffa1\017\uffa1\021\uffa1\027\uffa1\030\uffa1\031" +
    "\uffa1\033\uffa1\035\uffa1\036\uffa1\037\uffa1\057\uffa1\060\uffa1" +
    "\061\uffa1\062\uffa1\063\uffa1\064\uffa1\065\uffa1\001\002\000" +
    "\004\012\u011f\001\002\000\054\010\uff7b\011\uff7b\012\uff7b" +
    "\013\uff7b\014\uff7b\015\uff7b\022\uff7b\023\uff7b\040\uff7b\041" +
    "\uff7b\043\uff7b\044\uff7b\045\uff7b\046\uff7b\047\uff7b\050\uff7b" +
    "\051\uff7b\052\uff7b\053\uff7b\054\uff7b\055\uff7b\001\002\000" +
    "\004\012\u0129\001\002\000\006\012\uff6e\020\uff14\001\002" +
    "\000\060\003\uffa8\004\uffa8\005\uffa8\006\uffa8\007\uffa8\013" +
    "\uffa8\016\uffa8\017\uffa8\021\uffa8\027\uffa8\030\uffa8\031\uffa8" +
    "\033\uffa8\035\uffa8\036\uffa8\037\uffa8\057\uffa8\060\uffa8\061" +
    "\uffa8\062\uffa8\063\uffa8\064\uffa8\065\uffa8\001\002\000\004" +
    "\020\241\001\002\000\004\012\237\001\002\000\004\030" +
    "\240\001\002\000\054\010\uff6d\011\uff6d\012\uff6d\013\uff6d" +
    "\014\uff6d\015\uff6d\022\uff6d\023\uff6d\040\uff6d\041\uff6d\043" +
    "\uff6d\044\uff6d\045\uff6d\046\uff6d\047\uff6d\050\uff6d\051\uff6d" +
    "\052\uff6d\053\uff6d\054\uff6d\055\uff6d\001\002\000\054\003" +
    "\255\004\041\005\037\006\052\007\051\021\153\027\202" +
    "\030\231\031\232\032\266\037\177\040\253\041\244\042" +
    "\246\057\221\060\205\061\161\062\162\063\150\064\062" +
    "\065\170\001\002\000\042\011\uff3b\013\uff3b\015\uff3b\022" +
    "\uff3b\023\uff3b\040\344\041\345\045\uff3b\046\uff3b\047\uff3b" +
    "\050\uff3b\051\uff3b\052\uff3b\053\uff3b\054\uff3b\055\uff3b\001" +
    "\002\000\022\011\uff21\013\uff21\015\uff21\022\uff21\023\uff21" +
    "\053\u0103\054\uff21\055\uff21\001\002\000\054\003\306\004" +
    "\041\005\037\006\052\007\051\021\153\027\202\030\231" +
    "\031\232\032\266\037\177\040\253\041\244\042\246\057" +
    "\221\060\205\061\161\062\162\063\150\064\062\065\170" +
    "\001\002\000\060\010\313\011\uff4f\012\315\013\uff4f\014" +
    "\uff4f\015\uff4f\020\uff12\021\314\022\uff4f\023\uff4f\040\uff4f" +
    "\041\uff4f\043\uff4f\044\uff4f\045\uff4f\046\uff4f\047\uff4f\050" +
    "\uff4f\051\uff4f\052\uff4f\053\uff4f\054\uff4f\055\uff4f\001\002" +
    "\000\054\003\uff4d\004\uff4d\005\uff4d\006\uff4d\007\uff4d\021" +
    "\uff4d\027\uff4d\030\uff4d\031\uff4d\032\uff4d\037\uff4d\040\uff4d" +
    "\041\uff4d\042\uff4d\057\uff4d\060\uff4d\061\uff4d\062\uff4d\063" +
    "\uff4d\064\uff4d\065\uff4d\001\002\000\026\011\uff26\013\uff26" +
    "\015\uff26\022\uff26\023\uff26\051\373\052\372\053\uff26\054" +
    "\uff26\055\uff26\001\002\000\004\012\u0124\001\002\000\014" +
    "\011\uff16\013\uff16\015\uff16\022\uff16\023\uff16\001\002\000" +
    "\052\011\uff50\012\u011f\013\uff50\014\uff50\015\uff50\022\uff50" +
    "\023\uff50\040\uff50\041\uff50\043\uff50\044\uff50\045\uff50\046" +
    "\uff50\047\uff50\050\uff50\051\uff50\052\uff50\053\uff50\054\uff50" +
    "\055\uff50\001\002\000\054\003\306\004\041\005\037\006" +
    "\052\007\051\021\153\027\202\030\231\031\232\032\266" +
    "\037\177\040\253\041\244\042\246\057\221\060\205\061" +
    "\161\062\162\063\150\064\062\065\170\001\002\000\050" +
    "\011\uff48\013\uff48\014\uff48\015\uff48\022\uff48\023\uff48\040" +
    "\uff48\041\uff48\043\uff48\044\uff48\045\uff48\046\uff48\047\uff48" +
    "\050\uff48\051\uff48\052\uff48\053\uff48\054\uff48\055\uff48\001" +
    "\002\000\036\012\uff6e\014\uff44\020\uff14\043\uff42\044\uff40" +
    "\045\uff36\046\uff34\047\uff32\050\uff30\051\uff2b\052\uff29\053" +
    "\uff24\054\uff1f\055\uff19\001\002\000\014\011\uff17\013\uff17" +
    "\015\uff17\022\uff17\023\uff17\001\002\000\050\011\uff4c\013" +
    "\uff4c\014\uff4c\015\uff4c\022\uff4c\023\uff4c\040\uff4c\041\uff4c" +
    "\043\uff4c\044\uff4c\045\uff4c\046\uff4c\047\uff4c\050\uff4c\051" +
    "\uff4c\052\uff4c\053\uff4c\054\uff4c\055\uff4c\001\002\000\006" +
    "\010\122\012\u011c\001\002\000\054\010\uff79\011\uff79\012" +
    "\uff79\013\uff79\014\uff79\015\uff79\022\uff79\023\uff79\040\uff79" +
    "\041\uff79\043\uff79\044\uff79\045\uff79\046\uff79\047\uff79\050" +
    "\uff79\051\uff79\052\uff79\053\uff79\054\uff79\055\uff79\001\002" +
    "\000\020\011\uff1b\013\uff1b\015\uff1b\022\uff1b\023\uff1b\054" +
    "\u010b\055\u0115\001\002\000\014\011\uff13\013\uff13\015\uff13" +
    "\022\uff13\023\uff13\001\002\000\054\010\uff77\011\uff77\012" +
    "\uff77\013\uff77\014\uff77\015\uff77\022\uff77\023\uff77\040\uff77" +
    "\041\uff77\043\uff77\044\uff77\045\uff77\046\uff77\047\uff77\050" +
    "\uff77\051\uff77\052\uff77\053\uff77\054\uff77\055\uff77\001\002" +
    "\000\050\011\uff3e\013\uff3e\014\350\015\uff3e\022\uff3e\023" +
    "\uff3e\040\uff3e\041\uff3e\043\351\044\347\045\uff3e\046\uff3e" +
    "\047\uff3e\050\uff3e\051\uff3e\052\uff3e\053\uff3e\054\uff3e\055" +
    "\uff3e\001\002\000\004\064\062\001\002\000\036\011\uff2e" +
    "\013\uff2e\015\uff2e\022\uff2e\023\uff2e\045\270\046\272\047" +
    "\273\050\271\051\uff2e\052\uff2e\053\uff2e\054\uff2e\055\uff2e" +
    "\001\002\000\054\003\277\004\041\005\037\006\052\007" +
    "\051\021\153\027\202\030\231\031\232\032\266\037\177" +
    "\040\253\041\244\042\246\057\221\060\205\061\161\062" +
    "\162\063\150\064\062\065\170\001\002\000\054\003\277" +
    "\004\041\005\037\006\052\007\051\021\153\027\202\030" +
    "\231\031\232\032\266\037\177\040\253\041\244\042\246" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\054\003\277\004\041\005\037\006\052" +
    "\007\051\021\153\027\202\030\231\031\232\032\266\037" +
    "\177\040\253\041\244\042\246\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\054\003" +
    "\277\004\041\005\037\006\052\007\051\021\153\027\202" +
    "\030\231\031\232\032\266\037\177\040\253\041\244\042" +
    "\246\057\221\060\205\061\161\062\162\063\150\064\062" +
    "\065\170\001\002\000\054\010\uff78\011\uff78\012\uff78\013" +
    "\uff78\014\uff78\015\uff78\022\uff78\023\uff78\040\uff78\041\uff78" +
    "\043\uff78\044\uff78\045\uff78\046\uff78\047\uff78\050\uff78\051" +
    "\uff78\052\uff78\053\uff78\054\uff78\055\uff78\001\002\000\042" +
    "\011\uff38\013\uff38\015\uff38\022\uff38\023\uff38\040\344\041" +
    "\345\045\uff38\046\uff38\047\uff38\050\uff38\051\uff38\052\uff38" +
    "\053\uff38\054\uff38\055\uff38\001\002\000\056\010\313\011" +
    "\uff4f\012\315\013\uff4f\014\uff4f\015\uff4f\021\314\022\uff4f" +
    "\023\uff4f\040\uff4f\041\uff4f\043\uff4f\044\uff4f\045\uff4f\046" +
    "\uff4f\047\uff4f\050\uff4f\051\uff4f\052\uff4f\053\uff4f\054\uff4f" +
    "\055\uff4f\001\002\000\012\012\uff6e\014\uff44\043\uff42\044" +
    "\uff40\001\002\000\054\010\uff76\011\uff76\012\uff76\013\uff76" +
    "\014\uff76\015\uff76\022\uff76\023\uff76\040\uff76\041\uff76\043" +
    "\uff76\044\uff76\045\uff76\046\uff76\047\uff76\050\uff76\051\uff76" +
    "\052\uff76\053\uff76\054\uff76\055\uff76\001\002\000\004\014" +
    "\311\001\002\000\004\044\307\001\002\000\004\043\304" +
    "\001\002\000\054\003\306\004\041\005\037\006\052\007" +
    "\051\021\153\027\202\030\231\031\232\032\266\037\177" +
    "\040\253\041\244\042\246\057\221\060\205\061\161\062" +
    "\162\063\150\064\062\065\170\001\002\000\050\011\uff41" +
    "\013\uff41\014\uff41\015\uff41\022\uff41\023\uff41\040\uff41\041" +
    "\uff41\043\uff41\044\uff41\045\uff41\046\uff41\047\uff41\050\uff41" +
    "\051\uff41\052\uff41\053\uff41\054\uff41\055\uff41\001\002\000" +
    "\004\012\uff6e\001\002\000\054\003\306\004\041\005\037" +
    "\006\052\007\051\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\050\011\uff3f\013\uff3f\014\uff3f\015\uff3f\022\uff3f\023\uff3f" +
    "\040\uff3f\041\uff3f\043\uff3f\044\uff3f\045\uff3f\046\uff3f\047" +
    "\uff3f\050\uff3f\051\uff3f\052\uff3f\053\uff3f\054\uff3f\055\uff3f" +
    "\001\002\000\054\003\306\004\041\005\037\006\052\007" +
    "\051\021\153\027\202\030\231\031\232\032\266\037\177" +
    "\040\253\041\244\042\246\057\221\060\205\061\161\062" +
    "\162\063\150\064\062\065\170\001\002\000\050\011\uff43" +
    "\013\uff43\014\uff43\015\uff43\022\uff43\023\uff43\040\uff43\041" +
    "\uff43\043\uff43\044\uff43\045\uff43\046\uff43\047\uff43\050\uff43" +
    "\051\uff43\052\uff43\053\uff43\054\uff43\055\uff43\001\002\000" +
    "\056\003\255\004\041\005\037\006\052\007\051\011\126" +
    "\021\153\027\202\030\231\031\232\032\266\037\177\040" +
    "\253\041\244\042\246\057\221\060\205\061\161\062\162" +
    "\063\150\064\062\065\170\001\002\000\056\003\322\004" +
    "\041\005\037\006\052\007\051\021\153\022\uff68\027\202" +
    "\030\231\031\232\032\266\037\177\040\253\041\244\042" +
    "\246\057\221\060\205\061\161\062\162\063\150\064\062" +
    "\065\170\001\002\000\010\025\317\030\316\064\136\001" +
    "\002\000\054\010\uff71\011\uff71\012\uff71\013\uff71\014\uff71" +
    "\015\uff71\022\uff71\023\uff71\040\uff71\041\uff71\043\uff71\044" +
    "\uff71\045\uff71\046\uff71\047\uff71\050\uff71\051\uff71\052\uff71" +
    "\053\uff71\054\uff71\055\uff71\001\002\000\054\010\uff72\011" +
    "\uff72\012\uff72\013\uff72\014\uff72\015\uff72\022\uff72\023\uff72" +
    "\040\uff72\041\uff72\043\uff72\044\uff72\045\uff72\046\uff72\047" +
    "\uff72\050\uff72\051\uff72\052\uff72\053\uff72\054\uff72\055\uff72" +
    "\001\002\000\004\022\u010e\001\002\000\006\015\uff66\022" +
    "\uff66\001\002\000\110\003\uff64\004\uff64\005\uff64\006\uff64" +
    "\007\uff64\012\uff6e\014\uff44\020\uff14\021\uff64\027\uff64\030" +
    "\uff64\031\uff64\032\uff64\037\uff64\040\uff64\041\uff64\042\uff64" +
    "\043\uff42\044\uff40\045\uff36\046\uff34\047\uff32\050\uff30\051" +
    "\uff2b\052\uff29\053\uff24\054\uff1f\055\uff19\057\uff64\060\uff64" +
    "\061\uff64\062\uff64\063\uff64\064\uff64\065\uff64\001\002\000" +
    "\006\015\325\022\uff67\001\002\000\014\011\uff0d\013\uff0d" +
    "\015\uff0d\022\uff0d\023\uff0d\001\002\000\054\003\255\004" +
    "\041\005\037\006\052\007\051\021\153\027\202\030\231" +
    "\031\232\032\266\037\177\040\253\041\244\042\246\057" +
    "\221\060\205\061\161\062\162\063\150\064\062\065\170" +
    "\001\002\000\006\015\uff65\022\uff65\001\002\000\004\055" +
    "\u0106\001\002\000\004\054\u0100\001\002\000\004\051\376" +
    "\001\002\000\004\053\367\001\002\000\004\050\365\001" +
    "\002\000\004\052\362\001\002\000\004\047\360\001\002" +
    "\000\004\046\356\001\002\000\004\045\342\001\002\000" +
    "\054\003\255\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\006\015\uff63\022\uff63\001" +
    "\002\000\054\003\277\004\041\005\037\006\052\007\051" +
    "\021\153\027\202\030\231\031\232\032\266\037\177\040" +
    "\253\041\244\042\246\057\221\060\205\061\161\062\162" +
    "\063\150\064\062\065\170\001\002\000\042\011\uff35\013" +
    "\uff35\015\uff35\022\uff35\023\uff35\040\344\041\345\045\uff35" +
    "\046\uff35\047\uff35\050\uff35\051\uff35\052\uff35\053\uff35\054" +
    "\uff35\055\uff35\001\002\000\054\003\277\004\041\005\037" +
    "\006\052\007\051\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\054\003\277\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\050\011\uff3c\013\uff3c\014" +
    "\350\015\uff3c\022\uff3c\023\uff3c\040\uff3c\041\uff3c\043\351" +
    "\044\347\045\uff3c\046\uff3c\047\uff3c\050\uff3c\051\uff3c\052" +
    "\uff3c\053\uff3c\054\uff3c\055\uff3c\001\002\000\054\003\306" +
    "\004\041\005\037\006\052\007\051\021\153\027\202\030" +
    "\231\031\232\032\266\037\177\040\253\041\244\042\246" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\054\003\306\004\041\005\037\006\052" +
    "\007\051\021\153\027\202\030\231\031\232\032\266\037" +
    "\177\040\253\041\244\042\246\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\054\003" +
    "\306\004\041\005\037\006\052\007\051\021\153\027\202" +
    "\030\231\031\232\032\266\037\177\040\253\041\244\042" +
    "\246\057\221\060\205\061\161\062\162\063\150\064\062" +
    "\065\170\001\002\000\050\011\uff46\013\uff46\014\uff46\015" +
    "\uff46\022\uff46\023\uff46\040\uff46\041\uff46\043\uff46\044\uff46" +
    "\045\uff46\046\uff46\047\uff46\050\uff46\051\uff46\052\uff46\053" +
    "\uff46\054\uff46\055\uff46\001\002\000\050\011\uff47\013\uff47" +
    "\014\uff47\015\uff47\022\uff47\023\uff47\040\uff47\041\uff47\043" +
    "\uff47\044\uff47\045\uff47\046\uff47\047\uff47\050\uff47\051\uff47" +
    "\052\uff47\053\uff47\054\uff47\055\uff47\001\002\000\050\011" +
    "\uff45\013\uff45\014\uff45\015\uff45\022\uff45\023\uff45\040\uff45" +
    "\041\uff45\043\uff45\044\uff45\045\uff45\046\uff45\047\uff45\050" +
    "\uff45\051\uff45\052\uff45\053\uff45\054\uff45\055\uff45\001\002" +
    "\000\050\011\uff3d\013\uff3d\014\350\015\uff3d\022\uff3d\023" +
    "\uff3d\040\uff3d\041\uff3d\043\351\044\347\045\uff3d\046\uff3d" +
    "\047\uff3d\050\uff3d\051\uff3d\052\uff3d\053\uff3d\054\uff3d\055" +
    "\uff3d\001\002\000\054\003\277\004\041\005\037\006\052" +
    "\007\051\021\153\027\202\030\231\031\232\032\266\037" +
    "\177\040\253\041\244\042\246\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\042\011" +
    "\uff33\013\uff33\015\uff33\022\uff33\023\uff33\040\344\041\345" +
    "\045\uff33\046\uff33\047\uff33\050\uff33\051\uff33\052\uff33\053" +
    "\uff33\054\uff33\055\uff33\001\002\000\054\003\277\004\041" +
    "\005\037\006\052\007\051\021\153\027\202\030\231\031" +
    "\232\032\266\037\177\040\253\041\244\042\246\057\221" +
    "\060\205\061\161\062\162\063\150\064\062\065\170\001" +
    "\002\000\042\011\uff31\013\uff31\015\uff31\022\uff31\023\uff31" +
    "\040\344\041\345\045\uff31\046\uff31\047\uff31\050\uff31\051" +
    "\uff31\052\uff31\053\uff31\054\uff31\055\uff31\001\002\000\054" +
    "\003\363\004\041\005\037\006\052\007\051\021\153\027" +
    "\202\030\231\031\232\032\266\037\177\040\253\041\244" +
    "\042\246\057\221\060\205\061\161\062\162\063\150\064" +
    "\062\065\170\001\002\000\022\012\uff6e\014\uff44\043\uff42" +
    "\044\uff40\045\uff36\046\uff34\047\uff32\050\uff30\001\002\000" +
    "\036\011\uff28\013\uff28\015\uff28\022\uff28\023\uff28\045\270" +
    "\046\272\047\273\050\271\051\uff28\052\uff28\053\uff28\054" +
    "\uff28\055\uff28\001\002\000\054\003\277\004\041\005\037" +
    "\006\052\007\051\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\042\011\uff2f\013\uff2f\015\uff2f\022\uff2f\023\uff2f\040\344" +
    "\041\345\045\uff2f\046\uff2f\047\uff2f\050\uff2f\051\uff2f\052" +
    "\uff2f\053\uff2f\054\uff2f\055\uff2f\001\002\000\054\003\371" +
    "\004\041\005\037\006\052\007\051\021\153\027\202\030" +
    "\231\031\232\032\266\037\177\040\253\041\244\042\246" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\026\011\uff23\013\uff23\015\uff23\022\uff23" +
    "\023\uff23\051\373\052\372\053\uff23\054\uff23\055\uff23\001" +
    "\002\000\026\012\uff6e\014\uff44\043\uff42\044\uff40\045\uff36" +
    "\046\uff34\047\uff32\050\uff30\051\uff2b\052\uff29\001\002\000" +
    "\054\003\363\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\054\003\363\004\041\005" +
    "\037\006\052\007\051\021\153\027\202\030\231\031\232" +
    "\032\266\037\177\040\253\041\244\042\246\057\221\060" +
    "\205\061\161\062\162\063\150\064\062\065\170\001\002" +
    "\000\036\011\uff2d\013\uff2d\015\uff2d\022\uff2d\023\uff2d\045" +
    "\270\046\272\047\273\050\271\051\uff2d\052\uff2d\053\uff2d" +
    "\054\uff2d\055\uff2d\001\002\000\036\011\uff2c\013\uff2c\015" +
    "\uff2c\022\uff2c\023\uff2c\045\270\046\272\047\273\050\271" +
    "\051\uff2c\052\uff2c\053\uff2c\054\uff2c\055\uff2c\001\002\000" +
    "\054\003\363\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\036\011\uff2a\013\uff2a\015" +
    "\uff2a\022\uff2a\023\uff2a\045\270\046\272\047\273\050\271" +
    "\051\uff2a\052\uff2a\053\uff2a\054\uff2a\055\uff2a\001\002\000" +
    "\054\003\u0102\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\022\011\uff1e\013\uff1e\015" +
    "\uff1e\022\uff1e\023\uff1e\053\u0103\054\uff1e\055\uff1e\001\002" +
    "\000\030\012\uff6e\014\uff44\043\uff42\044\uff40\045\uff36\046" +
    "\uff34\047\uff32\050\uff30\051\uff2b\052\uff29\053\uff24\001\002" +
    "\000\054\003\uff27\004\uff27\005\uff27\006\uff27\007\uff27\021" +
    "\uff27\027\uff27\030\uff27\031\uff27\032\uff27\037\uff27\040\uff27" +
    "\041\uff27\042\uff27\057\uff27\060\uff27\061\uff27\062\uff27\063" +
    "\uff27\064\uff27\065\uff27\001\002\000\054\003\371\004\041" +
    "\005\037\006\052\007\051\021\153\027\202\030\231\031" +
    "\232\032\266\037\177\040\253\041\244\042\246\057\221" +
    "\060\205\061\161\062\162\063\150\064\062\065\170\001" +
    "\002\000\026\011\uff25\013\uff25\015\uff25\022\uff25\023\uff25" +
    "\051\373\052\372\053\uff25\054\uff25\055\uff25\001\002\000" +
    "\054\003\255\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\004\023\u0108\001\002\000" +
    "\054\003\u0109\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\032\012\uff6e\014\uff44\043" +
    "\uff42\044\uff40\045\uff36\046\uff34\047\uff32\050\uff30\051\uff2b" +
    "\052\uff29\053\uff24\054\uff1f\001\002\000\016\011\uff18\013" +
    "\uff18\015\uff18\022\uff18\023\uff18\054\u010b\001\002\000\054" +
    "\003\uff22\004\uff22\005\uff22\006\uff22\007\uff22\021\uff22\027" +
    "\uff22\030\uff22\031\uff22\032\uff22\037\uff22\040\uff22\041\uff22" +
    "\042\uff22\057\uff22\060\uff22\061\uff22\062\uff22\063\uff22\064" +
    "\uff22\065\uff22\001\002\000\054\003\u0102\004\041\005\037" +
    "\006\052\007\051\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\022\011\uff20\013\uff20\015\uff20\022\uff20\023\uff20\053\u0103" +
    "\054\uff20\055\uff20\001\002\000\054\010\uff55\011\uff55\012" +
    "\uff55\013\uff55\014\uff55\015\uff55\022\uff55\023\uff55\040\uff55" +
    "\041\uff55\043\uff55\044\uff55\045\uff55\046\uff55\047\uff55\050" +
    "\uff55\051\uff55\052\uff55\053\uff55\054\uff55\055\uff55\001\002" +
    "\000\004\011\u0110\001\002\000\056\010\uff52\011\uff52\012" +
    "\uff52\013\uff52\014\uff52\015\uff52\020\uff52\022\uff52\023\uff52" +
    "\040\uff52\041\uff52\043\uff52\044\uff52\045\uff52\046\uff52\047" +
    "\uff52\050\uff52\051\uff52\052\uff52\053\uff52\054\uff52\055\uff52" +
    "\001\002\000\042\011\uff39\013\uff39\015\uff39\022\uff39\023" +
    "\uff39\040\344\041\345\045\uff39\046\uff39\047\uff39\050\uff39" +
    "\051\uff39\052\uff39\053\uff39\054\uff39\055\uff39\001\002\000" +
    "\042\011\uff37\013\uff37\015\uff37\022\uff37\023\uff37\040\344" +
    "\041\345\045\uff37\046\uff37\047\uff37\050\uff37\051\uff37\052" +
    "\uff37\053\uff37\054\uff37\055\uff37\001\002\000\042\011\uff3a" +
    "\013\uff3a\015\uff3a\022\uff3a\023\uff3a\040\344\041\345\045" +
    "\uff3a\046\uff3a\047\uff3a\050\uff3a\051\uff3a\052\uff3a\053\uff3a" +
    "\054\uff3a\055\uff3a\001\002\000\052\011\uff4e\012\135\013" +
    "\uff4e\014\uff4e\015\uff4e\022\uff4e\023\uff4e\040\uff4e\041\uff4e" +
    "\043\uff4e\044\uff4e\045\uff4e\046\uff4e\047\uff4e\050\uff4e\051" +
    "\uff4e\052\uff4e\053\uff4e\054\uff4e\055\uff4e\001\002\000\054" +
    "\003\uff1d\004\uff1d\005\uff1d\006\uff1d\007\uff1d\021\uff1d\027" +
    "\uff1d\030\uff1d\031\uff1d\032\uff1d\037\uff1d\040\uff1d\041\uff1d" +
    "\042\uff1d\057\uff1d\060\uff1d\061\uff1d\062\uff1d\063\uff1d\064" +
    "\uff1d\065\uff1d\001\002\000\054\003\255\004\041\005\037" +
    "\006\052\007\051\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\004\023\u0118\001\002\000\054\003\uff1c\004\uff1c\005\uff1c" +
    "\006\uff1c\007\uff1c\021\uff1c\027\uff1c\030\uff1c\031\uff1c\032" +
    "\uff1c\037\uff1c\040\uff1c\041\uff1c\042\uff1c\057\uff1c\060\uff1c" +
    "\061\uff1c\062\uff1c\063\uff1c\064\uff1c\065\uff1c\001\002\000" +
    "\054\003\u011a\004\041\005\037\006\052\007\051\021\153" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\034\012\uff6e\014\uff44\043" +
    "\uff42\044\uff40\045\uff36\046\uff34\047\uff32\050\uff30\051\uff2b" +
    "\052\uff29\053\uff24\054\uff1f\055\uff19\001\002\000\014\011" +
    "\uff1a\013\uff1a\015\uff1a\022\uff1a\023\uff1a\001\002\000\004" +
    "\025\u011d\001\002\000\054\010\uff75\011\uff75\012\uff75\013" +
    "\uff75\014\uff75\015\uff75\022\uff75\023\uff75\040\uff75\041\uff75" +
    "\043\uff75\044\uff75\045\uff75\046\uff75\047\uff75\050\uff75\051" +
    "\uff75\052\uff75\053\uff75\054\uff75\055\uff75\001\002\000\050" +
    "\011\uff4a\013\uff4a\014\uff4a\015\uff4a\022\uff4a\023\uff4a\040" +
    "\uff4a\041\uff4a\043\uff4a\044\uff4a\045\uff4a\046\uff4a\047\uff4a" +
    "\050\uff4a\051\uff4a\052\uff4a\053\uff4a\054\uff4a\055\uff4a\001" +
    "\002\000\004\064\u0120\001\002\000\060\010\uff57\011\uff57" +
    "\012\uff57\013\uff57\014\uff57\015\uff57\020\uff57\021\u0121\022" +
    "\uff57\023\uff57\040\uff57\041\uff57\043\uff57\044\uff57\045\uff57" +
    "\046\uff57\047\uff57\050\uff57\051\uff57\052\uff57\053\uff57\054" +
    "\uff57\055\uff57\001\002\000\056\003\322\004\041\005\037" +
    "\006\052\007\051\021\153\022\uff68\027\202\030\231\031" +
    "\232\032\266\037\177\040\253\041\244\042\246\057\221" +
    "\060\205\061\161\062\162\063\150\064\062\065\170\001" +
    "\002\000\004\022\u0123\001\002\000\054\010\uff54\011\uff54" +
    "\012\uff54\013\uff54\014\uff54\015\uff54\022\uff54\023\uff54\040" +
    "\uff54\041\uff54\043\uff54\044\uff54\045\uff54\046\uff54\047\uff54" +
    "\050\uff54\051\uff54\052\uff54\053\uff54\054\uff54\055\uff54\001" +
    "\002\000\004\025\u0125\001\002\000\054\010\uff73\011\uff73" +
    "\012\uff73\013\uff73\014\uff73\015\uff73\022\uff73\023\uff73\040" +
    "\uff73\041\uff73\043\uff73\044\uff73\045\uff73\046\uff73\047\uff73" +
    "\050\uff73\051\uff73\052\uff73\053\uff73\054\uff73\055\uff73\001" +
    "\002\000\054\003\306\004\041\005\037\006\052\007\051" +
    "\021\153\027\202\030\231\031\232\032\266\037\177\040" +
    "\253\041\244\042\246\057\221\060\205\061\161\062\162" +
    "\063\150\064\062\065\170\001\002\000\050\011\uff4b\013" +
    "\uff4b\014\uff4b\015\uff4b\022\uff4b\023\uff4b\040\uff4b\041\uff4b" +
    "\043\uff4b\044\uff4b\045\uff4b\046\uff4b\047\uff4b\050\uff4b\051" +
    "\uff4b\052\uff4b\053\uff4b\054\uff4b\055\uff4b\001\002\000\050" +
    "\011\uff49\013\uff49\014\uff49\015\uff49\022\uff49\023\uff49\040" +
    "\uff49\041\uff49\043\uff49\044\uff49\045\uff49\046\uff49\047\uff49" +
    "\050\uff49\051\uff49\052\uff49\053\uff49\054\uff49\055\uff49\001" +
    "\002\000\004\064\u012a\001\002\000\060\010\uff56\011\uff56" +
    "\012\uff56\013\uff56\014\uff56\015\uff56\020\uff56\021\u012b\022" +
    "\uff56\023\uff56\040\uff56\041\uff56\043\uff56\044\uff56\045\uff56" +
    "\046\uff56\047\uff56\050\uff56\051\uff56\052\uff56\053\uff56\054" +
    "\uff56\055\uff56\001\002\000\056\003\322\004\041\005\037" +
    "\006\052\007\051\021\153\022\uff68\027\202\030\231\031" +
    "\232\032\266\037\177\040\253\041\244\042\246\057\221" +
    "\060\205\061\161\062\162\063\150\064\062\065\170\001" +
    "\002\000\004\022\u012d\001\002\000\054\010\uff53\011\uff53" +
    "\012\uff53\013\uff53\014\uff53\015\uff53\022\uff53\023\uff53\040" +
    "\uff53\041\uff53\043\uff53\044\uff53\045\uff53\046\uff53\047\uff53" +
    "\050\uff53\051\uff53\052\uff53\053\uff53\054\uff53\055\uff53\001" +
    "\002\000\004\022\uff84\001\002\000\054\003\uff8d\004\uff8d" +
    "\005\uff8d\006\uff8d\007\uff8d\021\uff8d\027\uff8d\030\uff8d\031" +
    "\uff8d\032\uff8d\037\uff8d\040\uff8d\041\uff8d\042\uff8d\057\uff8d" +
    "\060\uff8d\061\uff8d\062\uff8d\063\uff8d\064\uff8d\065\uff8d\001" +
    "\002\000\054\003\255\004\041\005\037\006\052\007\051" +
    "\021\153\027\202\030\231\031\232\032\266\037\177\040" +
    "\253\041\244\042\246\057\221\060\205\061\161\062\162" +
    "\063\150\064\062\065\170\001\002\000\004\022\uff8f\001" +
    "\002\000\004\022\u0133\001\002\000\056\003\233\004\041" +
    "\005\037\006\052\007\051\013\163\016\020\021\153\027" +
    "\202\030\231\031\232\033\171\035\211\036\175\037\177" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\012\010\313\012\315\020\uff12\021\314" +
    "\001\002\000\060\003\uff85\004\uff85\005\uff85\006\uff85\007" +
    "\uff85\013\uff85\016\uff85\017\uff85\021\uff85\027\uff85\030\uff85" +
    "\031\uff85\033\uff85\035\uff85\036\uff85\037\uff85\057\uff85\060" +
    "\uff85\061\uff85\062\uff85\063\uff85\064\uff85\065\uff85\001\002" +
    "\000\004\022\uff8f\001\002\000\004\022\u0138\001\002\000" +
    "\056\003\233\004\041\005\037\006\052\007\051\013\163" +
    "\016\020\021\153\027\202\030\231\031\232\033\171\035" +
    "\211\036\175\037\177\057\221\060\205\061\161\062\162" +
    "\063\150\064\062\065\170\001\002\000\060\003\uff83\004" +
    "\uff83\005\uff83\006\uff83\007\uff83\013\uff83\016\uff83\017\uff83" +
    "\021\uff83\027\uff83\030\uff83\031\uff83\033\uff83\035\uff83\036" +
    "\uff83\037\uff83\057\uff83\060\uff83\061\uff83\062\uff83\063\uff83" +
    "\064\uff83\065\uff83\001\002\000\054\003\255\004\041\005" +
    "\037\006\052\007\051\021\153\027\202\030\231\031\232" +
    "\032\266\037\177\040\253\041\244\042\246\057\221\060" +
    "\205\061\161\062\162\063\150\064\062\065\170\001\002" +
    "\000\004\011\u013c\001\002\000\056\010\uff51\011\uff51\012" +
    "\uff51\013\uff51\014\uff51\015\uff51\020\uff51\022\uff51\023\uff51" +
    "\040\uff51\041\uff51\043\uff51\044\uff51\045\uff51\046\uff51\047" +
    "\uff51\050\uff51\051\uff51\052\uff51\053\uff51\054\uff51\055\uff51" +
    "\001\002\000\004\025\u013e\001\002\000\054\010\uff74\011" +
    "\uff74\012\uff74\013\uff74\014\uff74\015\uff74\022\uff74\023\uff74" +
    "\040\uff74\041\uff74\043\uff74\044\uff74\045\uff74\046\uff74\047" +
    "\uff74\050\uff74\051\uff74\052\uff74\053\uff74\054\uff74\055\uff74" +
    "\001\002\000\030\003\uffb4\004\uffb4\005\uffb4\006\uffb4\007" +
    "\uffb4\013\uffb4\016\uffb4\017\uffb4\024\uffb4\027\uffb4\064\uffb4" +
    "\001\002\000\056\003\233\004\041\005\037\006\052\007" +
    "\051\013\163\016\020\021\153\027\202\030\231\031\232" +
    "\033\171\035\211\036\175\037\177\057\221\060\205\061" +
    "\161\062\162\063\150\064\062\065\170\001\002\000\060" +
    "\003\uffa6\004\uffa6\005\uffa6\006\uffa6\007\uffa6\013\uffa6\016" +
    "\uffa6\017\uffa6\021\uffa6\027\uffa6\030\uffa6\031\uffa6\033\uffa6" +
    "\035\uffa6\036\uffa6\037\uffa6\057\uffa6\060\uffa6\061\uffa6\062" +
    "\uffa6\063\uffa6\064\uffa6\065\uffa6\001\002\000\012\003\u0144" +
    "\010\u0146\012\135\021\uff6c\001\002\000\006\003\u0144\010" +
    "\u0146\001\002\000\004\010\uff5e\001\002\000\054\010\uff60" +
    "\011\uff60\012\uff60\013\uff60\014\uff60\015\uff60\022\uff60\023" +
    "\uff60\040\uff60\041\uff60\043\uff60\044\uff60\045\uff60\046\uff60" +
    "\047\uff60\050\uff60\051\uff60\052\uff60\053\uff60\054\uff60\055" +
    "\uff60\001\002\000\054\003\255\004\041\005\037\006\052" +
    "\007\051\021\153\027\202\030\231\031\232\032\266\037" +
    "\177\040\253\041\244\042\246\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\054\010" +
    "\u014a\011\uff5b\012\uff5b\013\uff5b\014\uff5b\015\uff5b\022\uff5b" +
    "\023\uff5b\040\uff5b\041\uff5b\043\uff5b\044\uff5b\045\uff5b\046" +
    "\uff5b\047\uff5b\050\uff5b\051\uff5b\052\uff5b\053\uff5b\054\uff5b" +
    "\055\uff5b\001\002\000\052\011\uff62\012\uff62\013\uff62\014" +
    "\uff62\015\uff62\022\uff62\023\uff62\040\uff62\041\uff62\043\uff62" +
    "\044\uff62\045\uff62\046\uff62\047\uff62\050\uff62\051\uff62\052" +
    "\uff62\053\uff62\054\uff62\055\uff62\001\002\000\054\010\uff5f" +
    "\011\uff5f\012\uff5f\013\uff5f\014\uff5f\015\uff5f\022\uff5f\023" +
    "\uff5f\040\uff5f\041\uff5f\043\uff5f\044\uff5f\045\uff5f\046\uff5f" +
    "\047\uff5f\050\uff5f\051\uff5f\052\uff5f\053\uff5f\054\uff5f\055" +
    "\uff5f\001\002\000\056\003\255\004\041\005\037\006\052" +
    "\007\051\011\126\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\054\010\124\011\uff5a\012\uff5a\013\uff5a\014\uff5a\015\uff5a" +
    "\022\uff5a\023\uff5a\040\uff5a\041\uff5a\043\uff5a\044\uff5a\045" +
    "\uff5a\046\uff5a\047\uff5a\050\uff5a\051\uff5a\052\uff5a\053\uff5a" +
    "\054\uff5a\055\uff5a\001\002\000\004\011\u014d\001\002\000" +
    "\054\010\uff5c\011\uff5c\012\uff5c\013\uff5c\014\uff5c\015\uff5c" +
    "\022\uff5c\023\uff5c\040\uff5c\041\uff5c\043\uff5c\044\uff5c\045" +
    "\uff5c\046\uff5c\047\uff5c\050\uff5c\051\uff5c\052\uff5c\053\uff5c" +
    "\054\uff5c\055\uff5c\001\002\000\004\010\u0146\001\002\000" +
    "\054\010\uff5d\011\uff5d\012\uff5d\013\uff5d\014\uff5d\015\uff5d" +
    "\022\uff5d\023\uff5d\040\uff5d\041\uff5d\043\uff5d\044\uff5d\045" +
    "\uff5d\046\uff5d\047\uff5d\050\uff5d\051\uff5d\052\uff5d\053\uff5d" +
    "\054\uff5d\055\uff5d\001\002\000\004\021\u0153\001\002\000" +
    "\054\010\u014a\011\uff5b\012\uff5b\013\uff5b\014\uff5b\015\uff5b" +
    "\022\uff5b\023\uff5b\040\uff5b\041\uff5b\043\uff5b\044\uff5b\045" +
    "\uff5b\046\uff5b\047\uff5b\050\uff5b\051\uff5b\052\uff5b\053\uff5b" +
    "\054\uff5b\055\uff5b\001\002\000\052\011\uff61\012\uff61\013" +
    "\uff61\014\uff61\015\uff61\022\uff61\023\uff61\040\uff61\041\uff61" +
    "\043\uff61\044\uff61\045\uff61\046\uff61\047\uff61\050\uff61\051" +
    "\uff61\052\uff61\053\uff61\054\uff61\055\uff61\001\002\000\056" +
    "\003\322\004\041\005\037\006\052\007\051\021\153\022" +
    "\uff68\027\202\030\231\031\232\032\266\037\177\040\253" +
    "\041\244\042\246\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\022\u0155\001\002" +
    "\000\056\010\uff6a\011\uff6a\012\uff6a\013\uff6a\014\uff6a\015" +
    "\uff6a\016\016\022\uff6a\023\uff6a\040\uff6a\041\uff6a\043\uff6a" +
    "\044\uff6a\045\uff6a\046\uff6a\047\uff6a\050\uff6a\051\uff6a\052" +
    "\uff6a\053\uff6a\054\uff6a\055\uff6a\001\002\000\054\010\uff6b" +
    "\011\uff6b\012\uff6b\013\uff6b\014\uff6b\015\uff6b\022\uff6b\023" +
    "\uff6b\040\uff6b\041\uff6b\043\uff6b\044\uff6b\045\uff6b\046\uff6b" +
    "\047\uff6b\050\uff6b\051\uff6b\052\uff6b\053\uff6b\054\uff6b\055" +
    "\uff6b\001\002\000\054\010\uff69\011\uff69\012\uff69\013\uff69" +
    "\014\uff69\015\uff69\022\uff69\023\uff69\040\uff69\041\uff69\043" +
    "\uff69\044\uff69\045\uff69\046\uff69\047\uff69\050\uff69\051\uff69" +
    "\052\uff69\053\uff69\054\uff69\055\uff69\001\002\000\056\003" +
    "\322\004\041\005\037\006\052\007\051\021\153\022\uff68" +
    "\027\202\030\231\031\232\032\266\037\177\040\253\041" +
    "\244\042\246\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\004\022\u015a\001\002\000" +
    "\004\013\u015b\001\002\000\060\003\uffb1\004\uffb1\005\uffb1" +
    "\006\uffb1\007\uffb1\013\uffb1\016\uffb1\017\uffb1\021\uffb1\027" +
    "\uffb1\030\uffb1\031\uffb1\033\uffb1\035\uffb1\036\uffb1\037\uffb1" +
    "\057\uffb1\060\uffb1\061\uffb1\062\uffb1\063\uffb1\064\uffb1\065" +
    "\uffb1\001\002\000\056\003\255\004\041\005\037\006\052" +
    "\007\051\013\uff0f\021\153\027\202\030\231\031\232\032" +
    "\266\037\177\040\253\041\244\042\246\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\004\013\uff0e\001\002\000\004\013\u015f\001\002\000\062" +
    "\003\uff80\004\uff80\005\uff80\006\uff80\007\uff80\013\uff80\016" +
    "\uff80\017\uff80\021\uff80\027\uff80\030\uff80\031\uff80\033\uff80" +
    "\034\uff80\035\uff80\036\uff80\037\uff80\057\uff80\060\uff80\061" +
    "\uff80\062\uff80\063\uff80\064\uff80\065\uff80\001\002\000\030" +
    "\003\uffb5\004\uffb5\005\uffb5\006\uffb5\007\uffb5\013\uffb5\016" +
    "\uffb5\017\uffb5\024\uffb5\027\uffb5\064\uffb5\001\002\000\056" +
    "\003\322\004\041\005\037\006\052\007\051\021\153\022" +
    "\uff68\027\202\030\231\031\232\032\266\037\177\040\253" +
    "\041\244\042\246\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\022\u0163\001\002" +
    "\000\004\013\u0164\001\002\000\060\003\uffb2\004\uffb2\005" +
    "\uffb2\006\uffb2\007\uffb2\013\uffb2\016\uffb2\017\uffb2\021\uffb2" +
    "\027\uffb2\030\uffb2\031\uffb2\033\uffb2\035\uffb2\036\uffb2\037" +
    "\uffb2\057\uffb2\060\uffb2\061\uffb2\062\uffb2\063\uffb2\064\uffb2" +
    "\065\uffb2\001\002\000\004\022\uff8b\001\002\000\054\003" +
    "\uff90\004\uff90\005\uff90\006\uff90\007\uff90\021\uff90\027\uff90" +
    "\030\uff90\031\uff90\032\uff90\037\uff90\040\uff90\041\uff90\042" +
    "\uff90\057\uff90\060\uff90\061\uff90\062\uff90\063\uff90\064\uff90" +
    "\065\uff90\001\002\000\054\003\u0169\004\041\005\037\006" +
    "\052\007\051\021\153\027\202\030\231\031\232\032\266" +
    "\037\177\040\253\041\244\042\246\057\221\060\205\061" +
    "\161\062\162\063\150\064\062\065\170\001\002\000\004" +
    "\022\uff8f\001\002\000\040\012\uff6e\014\uff44\020\uff14\022" +
    "\uff88\043\uff42\044\uff40\045\uff36\046\uff34\047\uff32\050\uff30" +
    "\051\uff2b\052\uff29\053\uff24\054\uff1f\055\uff19\001\002\000" +
    "\004\022\uff8f\001\002\000\004\022\u016c\001\002\000\056" +
    "\003\233\004\041\005\037\006\052\007\051\013\163\016" +
    "\020\021\153\027\202\030\231\031\232\033\u016f\035\u0171" +
    "\036\175\037\177\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\034\uff9b\001\002" +
    "\000\004\034\u0182\001\002\000\004\021\u0179\001\002\000" +
    "\004\034\uff9a\001\002\000\004\021\u0173\001\002\000\004" +
    "\034\uff9c\001\002\000\054\003\uff8d\004\uff8d\005\uff8d\006" +
    "\uff8d\007\uff8d\021\uff8d\027\uff8d\030\uff8d\031\uff8d\032\uff8d" +
    "\037\uff8d\040\uff8d\041\uff8d\042\uff8d\057\uff8d\060\uff8d\061" +
    "\uff8d\062\uff8d\063\uff8d\064\uff8d\065\uff8d\001\002\000\054" +
    "\003\255\004\041\005\037\006\052\007\051\021\153\027" +
    "\202\030\231\031\232\032\266\037\177\040\253\041\244" +
    "\042\246\057\221\060\205\061\161\062\162\063\150\064" +
    "\062\065\170\001\002\000\004\022\uff8f\001\002\000\004" +
    "\022\u0177\001\002\000\056\003\233\004\041\005\037\006" +
    "\052\007\051\013\163\016\020\021\153\027\202\030\231" +
    "\031\232\033\u016f\035\u0171\036\175\037\177\057\221\060" +
    "\205\061\161\062\162\063\150\064\062\065\170\001\002" +
    "\000\004\034\uff82\001\002\000\054\003\uff90\004\uff90\005" +
    "\uff90\006\uff90\007\uff90\021\uff90\027\uff90\030\uff90\031\uff90" +
    "\032\uff90\037\uff90\040\uff90\041\uff90\042\uff90\057\uff90\060" +
    "\uff90\061\uff90\062\uff90\063\uff90\064\uff90\065\uff90\001\002" +
    "\000\054\003\255\004\041\005\037\006\052\007\051\021" +
    "\153\027\202\030\231\031\232\032\266\037\177\040\253" +
    "\041\244\042\246\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\022\uff8f\001\002" +
    "\000\004\022\u017d\001\002\000\056\003\233\004\041\005" +
    "\037\006\052\007\051\013\163\016\020\021\153\027\202" +
    "\030\231\031\232\033\u016f\035\u0171\036\175\037\177\057" +
    "\221\060\205\061\161\062\162\063\150\064\062\065\170" +
    "\001\002\000\004\034\uff8e\001\002\000\004\034\u0180\001" +
    "\002\000\056\003\233\004\041\005\037\006\052\007\051" +
    "\013\163\016\020\021\153\027\202\030\231\031\232\033" +
    "\u016f\035\u0171\036\175\037\177\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\004\034" +
    "\uff86\001\002\000\056\003\233\004\041\005\037\006\052" +
    "\007\051\013\163\016\020\021\153\027\202\030\231\031" +
    "\232\033\171\035\211\036\175\037\177\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\060\003\uff87\004\uff87\005\uff87\006\uff87\007\uff87\013\uff87" +
    "\016\uff87\017\uff87\021\uff87\027\uff87\030\uff87\031\uff87\033" +
    "\uff87\035\uff87\036\uff87\037\uff87\057\uff87\060\uff87\061\uff87" +
    "\062\uff87\063\uff87\064\uff87\065\uff87\001\002\000\004\022" +
    "\u0185\001\002\000\056\003\233\004\041\005\037\006\052" +
    "\007\051\013\163\016\020\021\153\027\202\030\231\031" +
    "\232\033\u0187\035\u0189\036\175\037\177\057\221\060\205" +
    "\061\161\062\162\063\150\064\062\065\170\001\002\000" +
    "\004\034\uff8e\001\002\000\006\003\u0165\021\u0190\001\002" +
    "\000\060\003\uff8c\004\uff8c\005\uff8c\006\uff8c\007\uff8c\013" +
    "\uff8c\016\uff8c\017\uff8c\021\uff8c\027\uff8c\030\uff8c\031\uff8c" +
    "\033\uff8c\035\uff8c\036\uff8c\037\uff8c\057\uff8c\060\uff8c\061" +
    "\uff8c\062\uff8c\063\uff8c\064\uff8c\065\uff8c\001\002\000\006" +
    "\003\u012e\021\u018b\001\002\000\062\003\uffa0\004\uffa0\005" +
    "\uffa0\006\uffa0\007\uffa0\013\uffa0\016\uffa0\017\uffa0\021\uffa0" +
    "\027\uffa0\030\uffa0\031\uffa0\033\uffa0\034\uff9c\035\uffa0\036" +
    "\uffa0\037\uffa0\057\uffa0\060\uffa0\061\uffa0\062\uffa0\063\uffa0" +
    "\064\uffa0\065\uffa0\001\002\000\054\003\uff8d\004\uff8d\005" +
    "\uff8d\006\uff8d\007\uff8d\021\uff8d\027\uff8d\030\uff8d\031\uff8d" +
    "\032\uff8d\037\uff8d\040\uff8d\041\uff8d\042\uff8d\057\uff8d\060" +
    "\uff8d\061\uff8d\062\uff8d\063\uff8d\064\uff8d\065\uff8d\001\002" +
    "\000\054\003\255\004\041\005\037\006\052\007\051\021" +
    "\153\027\202\030\231\031\232\032\266\037\177\040\253" +
    "\041\244\042\246\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\022\uff8f\001\002" +
    "\000\004\022\u018f\001\002\000\056\003\233\004\041\005" +
    "\037\006\052\007\051\013\163\016\020\021\153\027\202" +
    "\030\231\031\232\033\u0187\035\u0189\036\175\037\177\057" +
    "\221\060\205\061\161\062\162\063\150\064\062\065\170" +
    "\001\002\000\054\003\uff90\004\uff90\005\uff90\006\uff90\007" +
    "\uff90\021\uff90\027\uff90\030\uff90\031\uff90\032\uff90\037\uff90" +
    "\040\uff90\041\uff90\042\uff90\057\uff90\060\uff90\061\uff90\062" +
    "\uff90\063\uff90\064\uff90\065\uff90\001\002\000\054\003\u0169" +
    "\004\041\005\037\006\052\007\051\021\153\027\202\030" +
    "\231\031\232\032\266\037\177\040\253\041\244\042\246" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\004\022\uff8f\001\002\000\004\022\u0194" +
    "\001\002\000\056\003\233\004\041\005\037\006\052\007" +
    "\051\013\163\016\020\021\153\027\202\030\231\031\232" +
    "\033\u0187\035\u0189\036\175\037\177\057\221\060\205\061" +
    "\161\062\162\063\150\064\062\065\170\001\002\000\004" +
    "\034\uff8e\001\002\000\004\034\u0197\001\002\000\056\003" +
    "\233\004\041\005\037\006\052\007\051\013\163\016\020" +
    "\021\153\027\202\030\231\031\232\033\u0187\035\u0189\036" +
    "\175\037\177\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\060\003\uff89\004\uff89\005" +
    "\uff89\006\uff89\007\uff89\013\uff89\016\uff89\017\uff89\021\uff89" +
    "\027\uff89\030\uff89\031\uff89\033\uff89\035\uff89\036\uff89\037" +
    "\uff89\057\uff89\060\uff89\061\uff89\062\uff89\063\uff89\064\uff89" +
    "\065\uff89\001\002\000\004\034\u019a\001\002\000\056\003" +
    "\233\004\041\005\037\006\052\007\051\013\163\016\020" +
    "\021\153\027\202\030\231\031\232\033\171\035\211\036" +
    "\175\037\177\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\004\022\uff8f\001\002\000" +
    "\004\022\u019d\001\002\000\056\003\233\004\041\005\037" +
    "\006\052\007\051\013\163\016\020\021\153\027\202\030" +
    "\231\031\232\033\171\035\211\036\175\037\177\057\221" +
    "\060\205\061\161\062\162\063\150\064\062\065\170\001" +
    "\002\000\060\003\uff8a\004\uff8a\005\uff8a\006\uff8a\007\uff8a" +
    "\013\uff8a\016\uff8a\017\uff8a\021\uff8a\027\uff8a\030\uff8a\031" +
    "\uff8a\033\uff8a\035\uff8a\036\uff8a\037\uff8a\057\uff8a\060\uff8a" +
    "\061\uff8a\062\uff8a\063\uff8a\064\uff8a\065\uff8a\001\002\000" +
    "\010\030\u01a1\031\u01a0\064\u0120\001\002\000\004\021\u01a6" +
    "\001\002\000\004\021\u01a2\001\002\000\056\003\322\004" +
    "\041\005\037\006\052\007\051\021\153\022\uff68\027\202" +
    "\030\231\031\232\032\266\037\177\040\253\041\244\042" +
    "\246\057\221\060\205\061\161\062\162\063\150\064\062" +
    "\065\170\001\002\000\004\022\u01a4\001\002\000\004\013" +
    "\u01a5\001\002\000\060\003\uffb0\004\uffb0\005\uffb0\006\uffb0" +
    "\007\uffb0\013\uffb0\016\uffb0\017\uffb0\021\uffb0\027\uffb0\030" +
    "\uffb0\031\uffb0\033\uffb0\035\uffb0\036\uffb0\037\uffb0\057\uffb0" +
    "\060\uffb0\061\uffb0\062\uffb0\063\uffb0\064\uffb0\065\uffb0\001" +
    "\002\000\056\003\322\004\041\005\037\006\052\007\051" +
    "\021\153\022\uff68\027\202\030\231\031\232\032\266\037" +
    "\177\040\253\041\244\042\246\057\221\060\205\061\161" +
    "\062\162\063\150\064\062\065\170\001\002\000\004\022" +
    "\u01a8\001\002\000\004\013\u01a9\001\002\000\060\003\uffaf" +
    "\004\uffaf\005\uffaf\006\uffaf\007\uffaf\013\uffaf\016\uffaf\017" +
    "\uffaf\021\uffaf\027\uffaf\030\uffaf\031\uffaf\033\uffaf\035\uffaf" +
    "\036\uffaf\037\uffaf\057\uffaf\060\uffaf\061\uffaf\062\uffaf\063" +
    "\uffaf\064\uffaf\065\uffaf\001\002\000\004\017\u01ac\001\002" +
    "\000\062\003\uffa7\004\uffa7\005\uffa7\006\uffa7\007\uffa7\012" +
    "\uff6e\013\uffa7\016\uffa7\020\uff14\021\uffa7\027\uffa7\030\uffa7" +
    "\031\uffa7\033\uffa7\035\uffa7\036\uffa7\037\uffa7\057\uffa7\060" +
    "\uffa7\061\uffa7\062\uffa7\063\uffa7\064\uffa7\065\uffa7\001\002" +
    "\000\030\003\uffb6\004\uffb6\005\uffb6\006\uffb6\007\uffb6\013" +
    "\uffb6\016\uffb6\017\uffb6\024\uffb6\027\uffb6\064\uffb6\001\002" +
    "\000\054\003\u01af\004\041\005\037\006\052\007\051\021" +
    "\153\027\202\030\231\031\232\032\266\037\177\040\253" +
    "\041\244\042\246\057\221\060\205\061\161\062\162\063" +
    "\150\064\062\065\170\001\002\000\004\022\u01b2\001\002" +
    "\000\040\012\uff6e\014\uff44\020\uff14\022\uff70\043\uff42\044" +
    "\uff40\045\uff36\046\uff34\047\uff32\050\uff30\051\uff2b\052\uff29" +
    "\053\uff24\054\uff1f\055\uff19\001\002\000\004\022\u01b1\001" +
    "\002\000\054\010\uff6f\011\uff6f\012\uff6f\013\uff6f\014\uff6f" +
    "\015\uff6f\022\uff6f\023\uff6f\040\uff6f\041\uff6f\043\uff6f\044" +
    "\uff6f\045\uff6f\046\uff6f\047\uff6f\050\uff6f\051\uff6f\052\uff6f" +
    "\053\uff6f\054\uff6f\055\uff6f\001\002\000\054\010\uff7a\011" +
    "\uff7a\012\uff7a\013\uff7a\014\uff7a\015\uff7a\022\uff7a\023\uff7a" +
    "\040\uff7a\041\uff7a\043\uff7a\044\uff7a\045\uff7a\046\uff7a\047" +
    "\uff7a\050\uff7a\051\uff7a\052\uff7a\053\uff7a\054\uff7a\055\uff7a" +
    "\001\002\000\054\003\uff81\004\uff81\005\uff81\006\uff81\007" +
    "\uff81\021\uff81\027\uff81\030\uff81\031\uff81\032\uff81\037\uff81" +
    "\040\uff81\041\uff81\042\uff81\057\uff81\060\uff81\061\uff81\062" +
    "\uff81\063\uff81\064\uff81\065\uff81\001\002\000\054\003\255" +
    "\004\041\005\037\006\052\007\051\021\153\027\202\030" +
    "\231\031\232\032\266\037\177\040\253\041\244\042\246" +
    "\057\221\060\205\061\161\062\162\063\150\064\062\065" +
    "\170\001\002\000\014\011\uff15\013\uff15\015\uff15\022\uff15" +
    "\023\uff15\001\002\000\062\003\uff94\004\uff94\005\uff94\006" +
    "\uff94\007\uff94\013\uff94\016\uff94\017\uff94\021\uff94\027\uff94" +
    "\030\uff94\031\uff94\033\uff94\034\uff94\035\uff94\036\uff94\037" +
    "\uff94\057\uff94\060\uff94\061\uff94\062\uff94\063\uff94\064\uff94" +
    "\065\uff94\001\002\000\030\003\uffde\004\uffde\005\uffde\006" +
    "\uffde\007\uffde\013\uffde\016\uffde\017\uffde\024\uffde\027\uffde" +
    "\064\uffde\001\002\000\030\003\uffcb\004\uffcb\005\uffcb\006" +
    "\uffcb\007\uffcb\013\uffcb\016\uffcb\017\uffcb\024\uffcb\027\uffcb" +
    "\064\uffcb\001\002\000\060\003\uffba\004\uffba\005\uffba\006" +
    "\uffba\007\uffba\013\uffba\016\uffba\017\uffba\021\uffba\027\uffba" +
    "\030\uffba\031\uffba\033\uffba\035\uffba\036\uffba\037\uffba\057" +
    "\uffba\060\uffba\061\uffba\062\uffba\063\uffba\064\uffba\065\uffba" +
    "\001\002\000\030\003\uffbb\004\uffbb\005\uffbb\006\uffbb\007" +
    "\uffbb\013\uffbb\016\uffbb\017\uffbb\024\uffbb\027\uffbb\064\uffbb" +
    "\001\002\000\060\003\u01bd\004\041\005\037\006\052\007" +
    "\051\013\163\016\020\017\uffab\021\153\027\202\030\231" +
    "\031\232\033\171\035\211\036\175\037\177\057\221\060" +
    "\205\061\161\062\162\063\150\064\062\065\170\001\002" +
    "\000\004\017\u01bf\001\002\000\064\003\uffa7\004\uffa7\005" +
    "\uffa7\006\uffa7\007\uffa7\012\uff6e\013\uffa7\016\uffa7\017\u01be" +
    "\020\uff14\021\uffa7\027\uffa7\030\uffa7\031\uffa7\033\uffa7\035" +
    "\uffa7\036\uffa7\037\uffa7\057\uffa7\060\uffa7\061\uffa7\062\uffa7" +
    "\063\uffa7\064\uffa7\065\uffa7\001\002\000\030\003\uffbc\004" +
    "\uffbc\005\uffbc\006\uffbc\007\uffbc\013\uffbc\016\uffbc\017\uffbc" +
    "\024\uffbc\027\uffbc\064\uffbc\001\002\000\030\003\uffbd\004" +
    "\uffbd\005\uffbd\006\uffbd\007\uffbd\013\uffbd\016\uffbd\017\uffbd" +
    "\024\uffbd\027\uffbd\064\uffbd\001\002\000\060\003\u01c2\004" +
    "\041\005\037\006\052\007\051\013\163\016\020\017\uffab" +
    "\021\153\027\202\030\231\031\232\033\171\035\211\036" +
    "\175\037\177\057\221\060\205\061\161\062\162\063\150" +
    "\064\062\065\170\001\002\000\004\017\u01c5\001\002\000" +
    "\064\003\uffa7\004\uffa7\005\uffa7\006\uffa7\007\uffa7\012\uff6e" +
    "\013\uffa7\016\uffa7\017\uffad\020\uff14\021\uffa7\027\uffa7\030" +
    "\uffa7\031\uffa7\033\uffa7\035\uffa7\036\uffa7\037\uffa7\057\uffa7" +
    "\060\uffa7\061\uffa7\062\uffa7\063\uffa7\064\uffa7\065\uffa7\001" +
    "\002\000\004\017\u01c4\001\002\000\064\003\uffac\004\uffac" +
    "\005\uffac\006\uffac\007\uffac\013\uffac\016\uffac\017\uffac\021" +
    "\uffac\024\uffac\027\uffac\030\uffac\031\uffac\033\uffac\034\uffac" +
    "\035\uffac\036\uffac\037\uffac\057\uffac\060\uffac\061\uffac\062" +
    "\uffac\063\uffac\064\uffac\065\uffac\001\002\000\064\003\uffae" +
    "\004\uffae\005\uffae\006\uffae\007\uffae\013\uffae\016\uffae\017" +
    "\uffae\021\uffae\024\uffae\027\uffae\030\uffae\031\uffae\033\uffae" +
    "\034\uffae\035\uffae\036\uffae\037\uffae\057\uffae\060\uffae\061" +
    "\uffae\062\uffae\063\uffae\064\uffae\065\uffae\001\002\000\004" +
    "\016\uffe4\001\002\000\004\016\016\001\002\000\010\002" +
    "\uffe3\024\uffe3\025\uffe3\001\002\000\006\024\010\025\uffec" +
    "\001\002\000\010\002\uffe7\024\uffe7\025\uffe7\001\002\000" +
    "\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01c9\000\006\002\003\013\005\001\001\000\002\001" +
    "\001\000\004\132\u01c8\001\001\000\006\014\010\017\006" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\133\014\001\001\000\002" +
    "\001\001\000\004\015\016\001\001\000\030\017\033\020" +
    "\024\021\034\022\030\023\032\024\031\027\023\031\020" +
    "\036\021\037\025\042\022\001\001\000\002\001\001\000" +
    "\004\043\u01bf\001\001\000\004\035\u01b7\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\024\017" +
    "\033\022\u01b6\023\032\024\031\027\023\031\020\036\021" +
    "\037\025\042\022\001\001\000\004\040\143\001\001\000" +
    "\004\142\136\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\004\044\005" +
    "\042\006\043\007\046\010\047\011\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\075" +
    "\133\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\075\122\001\001\000\002\001\001\000\006\025\076\026" +
    "\073\001\001\000\004\144\052\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\004\060\005\042\006\043\007\046" +
    "\010\047\011\037\032\054\033\055\034\056\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\143\066\001\001\000\004\026\062\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\004\060\005\042\006\043\007" +
    "\046\010\047\011\037\034\067\001\001\000\002\001\001" +
    "\000\020\004\060\005\042\006\043\007\046\010\047\011" +
    "\037\034\071\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\135\107\136\111\137\110\001" +
    "\001\000\004\140\103\001\001\000\002\001\001\000\004" +
    "\012\101\001\001\000\002\001\001\000\004\026\102\001" +
    "\001\000\002\001\001\000\002\001\001\000\024\004\060" +
    "\005\042\006\043\007\046\010\047\011\037\032\105\033" +
    "\055\034\056\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\017\112\027" +
    "\113\031\020\001\001\000\016\004\114\005\042\006\043" +
    "\007\046\010\047\011\037\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\140\103\001\001\000\004\026\117" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\141\127\001\001\000\002\001" +
    "\001\000\024\004\060\005\042\006\043\007\046\010\047" +
    "\011\037\032\131\033\055\034\056\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\004\060\005" +
    "\042\006\043\007\046\010\047\011\037\032\140\033\055" +
    "\034\056\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\030\144\001\001\000\002\001\001\000\100\003\153" +
    "\004\221\005\202\006\043\007\046\010\164\011\157\041" +
    "\156\042\155\044\172\045\215\046\212\047\211\050\173" +
    "\052\213\053\163\054\214\055\145\056\150\057\216\061" +
    "\207\063\200\064\166\065\205\066\203\071\154\111\146" +
    "\112\206\113\217\126\165\127\151\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\105\u01ac\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\076\003\153" +
    "\004\221\005\202\006\043\007\046\010\164\011\157\042" +
    "\155\044\u01a9\045\215\046\212\047\211\050\173\052\213" +
    "\053\163\054\214\055\145\056\150\057\216\061\207\063" +
    "\200\064\227\065\205\066\203\071\154\111\146\112\206" +
    "\113\217\126\165\127\151\001\001\000\004\075\133\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\110" +
    "\u015b\001\001\000\002\001\001\000\010\005\u0142\006\043" +
    "\011\u0141\001\001\000\010\146\u013f\154\235\174\234\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\075\122" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\072\003\153\004\221\005\202\006\043" +
    "\007\046\010\164\011\157\042\155\046\233\047\211\050" +
    "\173\052\213\053\163\054\214\055\145\056\150\057\216" +
    "\061\207\063\200\064\227\065\205\066\203\071\154\111" +
    "\146\112\206\113\217\126\165\127\151\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\025" +
    "\223\026\073\001\001\000\006\137\110\147\225\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\154\235\174\234\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\062\003\153\005\257\006\043\010" +
    "\247\011\244\064\251\065\205\066\260\071\154\111\146" +
    "\112\263\113\217\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\261\124\255\125\262\126\250" +
    "\127\151\001\001\000\002\001\001\000\002\001\001\000" +
    "\036\003\153\005\257\006\043\010\247\011\275\064\251" +
    "\065\205\066\260\071\154\111\273\112\263\113\277\114" +
    "\256\115\u0127\001\001\000\004\075\133\001\001\000\004" +
    "\104\u0125\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\036\003\153\005\257" +
    "\006\043\010\247\011\275\064\251\065\205\066\260\071" +
    "\154\111\273\112\263\113\277\114\256\115\u011d\001\001" +
    "\000\002\001\001\000\036\154\235\160\300\161\302\162" +
    "\301\163\336\164\335\165\334\166\332\167\330\170\333" +
    "\171\331\172\327\173\326\174\234\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\075\122\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\011\u0113\001\001\000\002" +
    "\001\001\000\042\003\153\005\257\006\043\010\247\011" +
    "\275\064\251\065\205\066\260\071\154\111\273\112\263" +
    "\113\277\114\256\115\253\116\264\117\u0112\001\001\000" +
    "\042\003\153\005\257\006\043\010\247\011\275\064\251" +
    "\065\205\066\260\071\154\111\273\112\263\113\277\114" +
    "\256\115\253\116\264\117\u0111\001\001\000\042\003\153" +
    "\005\257\006\043\010\247\011\275\064\251\065\205\066" +
    "\260\071\154\111\273\112\263\113\277\114\256\115\253" +
    "\116\264\117\u0110\001\001\000\042\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\253\116\264\117" +
    "\274\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\075\133\001\001\000\012\154\235\160\300\161\302\162" +
    "\301\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\036\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\304\001\001\000" +
    "\002\001\001\000\004\154\235\001\001\000\036\003\153" +
    "\005\257\006\043\010\247\011\275\064\251\065\205\066" +
    "\260\071\154\111\273\112\263\113\277\114\256\115\307" +
    "\001\001\000\002\001\001\000\036\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\311\001\001\000" +
    "\002\001\001\000\064\003\153\005\257\006\043\010\247" +
    "\011\244\064\251\065\205\066\260\071\154\111\146\112" +
    "\263\113\217\114\256\115\253\116\264\117\241\120\266" +
    "\121\246\122\242\123\261\124\255\125\323\126\250\127" +
    "\151\131\u010e\001\001\000\070\003\153\005\257\006\043" +
    "\010\247\011\244\064\251\065\205\066\260\067\317\070" +
    "\322\071\154\111\146\112\263\113\217\114\256\115\253" +
    "\116\264\117\241\120\266\121\246\122\242\123\261\124" +
    "\255\125\323\126\250\127\151\131\320\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\040\154\235\156\337\160\300" +
    "\161\302\162\301\163\336\164\335\165\334\166\332\167" +
    "\330\170\333\171\331\172\327\173\326\174\234\001\001" +
    "\000\002\001\001\000\002\001\001\000\064\003\153\005" +
    "\257\006\043\010\247\011\244\064\251\065\205\066\260" +
    "\071\154\111\146\112\263\113\217\114\256\115\253\116" +
    "\264\117\241\120\266\121\246\122\242\123\261\124\255" +
    "\125\323\126\250\127\151\131\325\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\064" +
    "\003\153\005\257\006\043\010\247\011\244\064\251\065" +
    "\205\066\260\071\154\111\146\112\263\113\217\114\256" +
    "\115\253\116\264\117\241\120\266\121\246\122\242\123" +
    "\261\124\255\125\323\126\250\127\151\131\340\001\001" +
    "\000\002\001\001\000\042\003\153\005\257\006\043\010" +
    "\247\011\275\064\251\065\205\066\260\071\154\111\273" +
    "\112\263\113\277\114\256\115\253\116\264\117\342\001" +
    "\001\000\002\001\001\000\040\003\153\005\257\006\043" +
    "\010\247\011\275\064\251\065\205\066\260\071\154\111" +
    "\273\112\263\113\277\114\256\115\253\116\354\001\001" +
    "\000\040\003\153\005\257\006\043\010\247\011\275\064" +
    "\251\065\205\066\260\071\154\111\273\112\263\113\277" +
    "\114\256\115\253\116\345\001\001\000\002\001\001\000" +
    "\036\003\153\005\257\006\043\010\247\011\275\064\251" +
    "\065\205\066\260\071\154\111\273\112\263\113\277\114" +
    "\256\115\353\001\001\000\036\003\153\005\257\006\043" +
    "\010\247\011\275\064\251\065\205\066\260\071\154\111" +
    "\273\112\263\113\277\114\256\115\352\001\001\000\036" +
    "\003\153\005\257\006\043\010\247\011\275\064\251\065" +
    "\205\066\260\071\154\111\273\112\263\113\277\114\256" +
    "\115\351\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\003\153\005\257" +
    "\006\043\010\247\011\275\064\251\065\205\066\260\071" +
    "\154\111\273\112\263\113\277\114\256\115\253\116\264" +
    "\117\356\001\001\000\002\001\001\000\042\003\153\005" +
    "\257\006\043\010\247\011\275\064\251\065\205\066\260" +
    "\071\154\111\273\112\263\113\277\114\256\115\253\116" +
    "\264\117\360\001\001\000\002\001\001\000\044\003\153" +
    "\005\257\006\043\010\247\011\275\064\251\065\205\066" +
    "\260\071\154\111\273\112\263\113\277\114\256\115\253" +
    "\116\264\117\241\120\363\001\001\000\022\154\235\160" +
    "\300\161\302\162\301\163\336\164\335\165\334\166\332" +
    "\001\001\000\002\001\001\000\042\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\253\116\264\117" +
    "\365\001\001\000\002\001\001\000\046\003\153\005\257" +
    "\006\043\010\247\011\275\064\251\065\205\066\260\071" +
    "\154\111\273\112\263\113\277\114\256\115\253\116\264" +
    "\117\241\120\266\121\367\001\001\000\002\001\001\000" +
    "\026\154\235\160\300\161\302\162\301\163\336\164\335" +
    "\165\334\166\332\167\330\170\333\001\001\000\044\003" +
    "\153\005\257\006\043\010\247\011\275\064\251\065\205" +
    "\066\260\071\154\111\273\112\263\113\277\114\256\115" +
    "\253\116\264\117\241\120\374\001\001\000\044\003\153" +
    "\005\257\006\043\010\247\011\275\064\251\065\205\066" +
    "\260\071\154\111\273\112\263\113\277\114\256\115\253" +
    "\116\264\117\241\120\373\001\001\000\002\001\001\000" +
    "\002\001\001\000\044\003\153\005\257\006\043\010\247" +
    "\011\275\064\251\065\205\066\260\071\154\111\273\112" +
    "\263\113\277\114\256\115\253\116\264\117\241\120\376" +
    "\001\001\000\002\001\001\000\050\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\253\116\264\117" +
    "\241\120\266\121\246\122\u0100\001\001\000\002\001\001" +
    "\000\030\154\235\160\300\161\302\162\301\163\336\164" +
    "\335\165\334\166\332\167\330\170\333\171\331\001\001" +
    "\000\004\102\u0103\001\001\000\046\003\153\005\257\006" +
    "\043\010\247\011\275\064\251\065\205\066\260\071\154" +
    "\111\273\112\263\113\277\114\256\115\253\116\264\117" +
    "\241\120\266\121\u0104\001\001\000\002\001\001\000\064" +
    "\003\153\005\257\006\043\010\247\011\244\064\251\065" +
    "\205\066\260\071\154\111\146\112\263\113\217\114\256" +
    "\115\253\116\264\117\241\120\266\121\246\122\242\123" +
    "\261\124\255\125\323\126\250\127\151\131\u0106\001\001" +
    "\000\002\001\001\000\052\003\153\005\257\006\043\010" +
    "\247\011\275\064\251\065\205\066\260\071\154\111\273" +
    "\112\263\113\277\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\u0109\001\001\000\032\154\235" +
    "\160\300\161\302\162\301\163\336\164\335\165\334\166" +
    "\332\167\330\170\333\171\331\172\327\001\001\000\002" +
    "\001\001\000\004\103\u010b\001\001\000\050\003\153\005" +
    "\257\006\043\010\247\011\275\064\251\065\205\066\260" +
    "\071\154\111\273\112\263\113\277\114\256\115\253\116" +
    "\264\117\241\120\266\121\246\122\u010c\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\106\u0115\001\001\000\064\003" +
    "\153\005\257\006\043\010\247\011\244\064\251\065\205" +
    "\066\260\071\154\111\146\112\263\113\217\114\256\115" +
    "\253\116\264\117\241\120\266\121\246\122\242\123\261" +
    "\124\255\125\323\126\250\127\151\131\u0116\001\001\000" +
    "\002\001\001\000\004\107\u0118\001\001\000\054\003\153" +
    "\005\257\006\043\010\247\011\275\064\251\065\205\066" +
    "\260\071\154\111\273\112\263\113\277\114\256\115\253" +
    "\116\264\117\241\120\266\121\246\122\242\123\261\124" +
    "\u011a\001\001\000\034\154\235\160\300\161\302\162\301" +
    "\163\336\164\335\165\334\166\332\167\330\170\333\171" +
    "\331\172\327\173\326\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\070\003\153\005\257\006\043" +
    "\010\247\011\244\064\251\065\205\066\260\067\u0121\070" +
    "\322\071\154\111\146\112\263\113\217\114\256\115\253" +
    "\116\264\117\241\120\266\121\246\122\242\123\261\124" +
    "\255\125\323\126\250\127\151\131\320\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\036\003\153\005\257\006\043\010\247\011\275" +
    "\064\251\065\205\066\260\071\154\111\273\112\263\113" +
    "\277\114\256\115\u0126\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\070\003" +
    "\153\005\257\006\043\010\247\011\244\064\251\065\205" +
    "\066\260\067\u012b\070\322\071\154\111\146\112\263\113" +
    "\217\114\256\115\253\116\264\117\241\120\266\121\246" +
    "\122\242\123\261\124\255\125\323\126\250\127\151\131" +
    "\320\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\152\u0135\001\001\000\004\101\u012f\001\001\000\064\003" +
    "\153\005\257\006\043\010\247\011\244\064\251\065\205" +
    "\066\260\071\154\111\146\112\263\113\217\114\256\115" +
    "\253\116\264\117\241\120\266\121\246\122\242\123\261" +
    "\124\255\125\323\126\250\127\151\131\u0130\001\001\000" +
    "\004\077\u0131\001\001\000\002\001\001\000\062\003\153" +
    "\005\257\006\043\010\247\011\u0133\042\155\050\u0134\052" +
    "\213\053\163\054\214\055\145\056\150\057\216\061\207" +
    "\063\200\064\227\065\205\066\203\071\154\111\146\112" +
    "\206\113\217\126\165\127\151\001\001\000\004\075\133" +
    "\001\001\000\002\001\001\000\004\077\u0136\001\001\000" +
    "\002\001\001\000\062\003\153\005\257\006\043\010\247" +
    "\011\u0133\042\155\050\u0138\052\213\053\163\054\214\055" +
    "\145\056\150\057\216\061\207\063\200\064\227\065\205" +
    "\066\203\071\154\111\146\112\206\113\217\126\165\127" +
    "\151\001\001\000\002\001\001\000\064\003\153\005\257" +
    "\006\043\010\247\011\244\064\251\065\205\066\260\071" +
    "\154\111\146\112\263\113\217\114\256\115\253\116\264" +
    "\117\241\120\266\121\246\122\242\123\261\124\255\125" +
    "\323\126\250\127\151\131\u013a\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\072\003\153\004\221\005\202\006\043" +
    "\007\046\010\164\011\157\042\155\046\u0140\047\211\050" +
    "\173\052\213\053\163\054\214\055\145\056\150\057\216" +
    "\061\207\063\200\064\227\065\205\066\203\071\154\111" +
    "\146\112\206\113\217\126\165\127\151\001\001\000\002" +
    "\001\001\000\010\072\u0150\073\u0144\155\u014f\001\001\000" +
    "\006\072\u0146\073\u0144\001\001\000\004\157\u014d\001\001" +
    "\000\002\001\001\000\064\003\153\005\257\006\043\010" +
    "\247\011\244\064\251\065\205\066\260\071\154\111\146" +
    "\112\263\113\217\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\261\124\255\125\323\126\250" +
    "\127\151\131\u014b\001\001\000\010\073\u0148\074\u0147\075" +
    "\u014a\001\001\000\002\001\001\000\002\001\001\000\064" +
    "\003\153\005\257\006\043\010\247\011\244\064\251\065" +
    "\205\066\260\071\154\111\146\112\263\113\217\114\256" +
    "\115\253\116\264\117\241\120\266\121\246\122\242\123" +
    "\261\124\255\125\323\126\250\127\151\131\u014b\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\073\u014e\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\073\u0148\074\u0151\075\u014a\001\001\000\002\001" +
    "\001\000\070\003\153\005\257\006\043\010\247\011\244" +
    "\064\251\065\205\066\260\067\u0153\070\322\071\154\111" +
    "\146\112\263\113\217\114\256\115\253\116\264\117\241" +
    "\120\266\121\246\122\242\123\261\124\255\125\323\126" +
    "\250\127\151\131\320\001\001\000\002\001\001\000\006" +
    "\015\u0156\016\u0155\001\001\000\002\001\001\000\002\001" +
    "\001\000\070\003\153\005\257\006\043\010\247\011\244" +
    "\064\251\065\205\066\260\067\u0158\070\322\071\154\111" +
    "\146\112\263\113\217\114\256\115\253\116\264\117\241" +
    "\120\266\121\246\122\242\123\261\124\255\125\323\126" +
    "\250\127\151\131\320\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\066\003\153\005\257\006" +
    "\043\010\247\011\244\064\251\065\205\066\260\071\154" +
    "\111\146\112\263\113\217\114\256\115\253\116\264\117" +
    "\241\120\266\121\246\122\242\123\261\124\255\125\323" +
    "\126\250\127\151\130\u015d\131\u015c\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\070\003\153\005\257\006\043\010\247\011\244\064" +
    "\251\065\205\066\260\067\u0161\070\322\071\154\111\146" +
    "\112\263\113\217\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\261\124\255\125\323\126\250" +
    "\127\151\131\320\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\150\u019a\001\001\000\004" +
    "\076\u0166\001\001\000\064\003\153\005\257\006\043\010" +
    "\247\011\244\064\251\065\205\066\260\071\154\111\146" +
    "\112\263\113\217\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\261\124\255\125\323\126\250" +
    "\127\151\131\u0167\001\001\000\004\077\u0183\001\001\000" +
    "\040\151\u0169\154\235\160\300\161\302\162\301\163\336" +
    "\164\335\165\334\166\332\167\330\170\333\171\331\172" +
    "\327\173\326\174\234\001\001\000\004\077\u016a\001\001" +
    "\000\002\001\001\000\060\003\153\005\257\006\043\010" +
    "\247\011\u0133\042\155\051\u016d\052\u0171\053\163\054\214" +
    "\055\145\060\u016c\062\u016f\063\200\064\227\065\205\066" +
    "\203\071\154\111\146\112\206\113\217\126\165\127\151" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\101\u0173\001\001\000\064\003\153\005\257\006" +
    "\043\010\247\011\244\064\251\065\205\066\260\071\154" +
    "\111\146\112\263\113\217\114\256\115\253\116\264\117" +
    "\241\120\266\121\246\122\242\123\261\124\255\125\323" +
    "\126\250\127\151\131\u0174\001\001\000\004\077\u0175\001" +
    "\001\000\002\001\001\000\060\003\153\005\257\006\043" +
    "\010\247\011\u0133\042\155\051\u0177\052\u0171\053\163\054" +
    "\214\055\145\060\u016c\062\u016f\063\200\064\227\065\205" +
    "\066\203\071\154\111\146\112\206\113\217\126\165\127" +
    "\151\001\001\000\002\001\001\000\004\076\u0179\001\001" +
    "\000\064\003\153\005\257\006\043\010\247\011\244\064" +
    "\251\065\205\066\260\071\154\111\146\112\263\113\217" +
    "\114\256\115\253\116\264\117\241\120\266\121\246\122" +
    "\242\123\261\124\255\125\323\126\250\127\151\131\u017a" +
    "\001\001\000\004\077\u017b\001\001\000\002\001\001\000" +
    "\060\003\153\005\257\006\043\010\247\011\u0133\042\155" +
    "\051\u017d\052\u0171\053\163\054\214\055\145\060\u016c\062" +
    "\u016f\063\200\064\227\065\205\066\203\071\154\111\146" +
    "\112\206\113\217\126\165\127\151\001\001\000\004\100" +
    "\u017e\001\001\000\002\001\001\000\060\003\153\005\257" +
    "\006\043\010\247\011\u0133\042\155\051\u0180\052\u0171\053" +
    "\163\054\214\055\145\060\u016c\062\u016f\063\200\064\227" +
    "\065\205\066\203\071\154\111\146\112\206\113\217\126" +
    "\165\127\151\001\001\000\002\001\001\000\062\003\153" +
    "\005\257\006\043\010\247\011\u0133\042\155\050\u0182\052" +
    "\213\053\163\054\214\055\145\056\150\057\216\061\207" +
    "\063\200\064\227\065\205\066\203\071\154\111\146\112" +
    "\206\113\217\126\165\127\151\001\001\000\002\001\001" +
    "\000\002\001\001\000\070\003\153\005\257\006\043\010" +
    "\247\011\u0133\042\155\050\u0187\051\u0185\052\u0189\053\163" +
    "\054\214\055\145\056\150\057\216\060\u016c\061\207\062" +
    "\u016f\063\200\064\227\065\205\066\203\071\154\111\146" +
    "\112\206\113\217\126\165\127\151\001\001\000\004\100" +
    "\u0198\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\101\u018b\001\001\000" +
    "\064\003\153\005\257\006\043\010\247\011\244\064\251" +
    "\065\205\066\260\071\154\111\146\112\263\113\217\114" +
    "\256\115\253\116\264\117\241\120\266\121\246\122\242" +
    "\123\261\124\255\125\323\126\250\127\151\131\u018c\001" +
    "\001\000\004\077\u018d\001\001\000\002\001\001\000\070" +
    "\003\153\005\257\006\043\010\247\011\u0133\042\155\050" +
    "\u0134\051\u0177\052\u0189\053\163\054\214\055\145\056\150" +
    "\057\216\060\u016c\061\207\062\u016f\063\200\064\227\065" +
    "\205\066\203\071\154\111\146\112\206\113\217\126\165" +
    "\127\151\001\001\000\004\076\u0190\001\001\000\064\003" +
    "\153\005\257\006\043\010\247\011\244\064\251\065\205" +
    "\066\260\071\154\111\146\112\263\113\217\114\256\115" +
    "\253\116\264\117\241\120\266\121\246\122\242\123\261" +
    "\124\255\125\323\126\250\127\151\131\u0191\001\001\000" +
    "\004\077\u0192\001\001\000\002\001\001\000\070\003\153" +
    "\005\257\006\043\010\247\011\u0133\042\155\050\u0187\051" +
    "\u0194\052\u0189\053\163\054\214\055\145\056\150\057\216" +
    "\060\u016c\061\207\062\u016f\063\200\064\227\065\205\066" +
    "\203\071\154\111\146\112\206\113\217\126\165\127\151" +
    "\001\001\000\004\100\u0195\001\001\000\002\001\001\000" +
    "\070\003\153\005\257\006\043\010\247\011\u0133\042\155" +
    "\050\u0197\051\u0180\052\u0189\053\163\054\214\055\145\056" +
    "\150\057\216\060\u016c\061\207\062\u016f\063\200\064\227" +
    "\065\205\066\203\071\154\111\146\112\206\113\217\126" +
    "\165\127\151\001\001\000\002\001\001\000\002\001\001" +
    "\000\062\003\153\005\257\006\043\010\247\011\u0133\042" +
    "\155\050\u0197\052\213\053\163\054\214\055\145\056\150" +
    "\057\216\061\207\063\200\064\227\065\205\066\203\071" +
    "\154\111\146\112\206\113\217\126\165\127\151\001\001" +
    "\000\004\077\u019b\001\001\000\002\001\001\000\062\003" +
    "\153\005\257\006\043\010\247\011\u0133\042\155\050\u019d" +
    "\052\213\053\163\054\214\055\145\056\150\057\216\061" +
    "\207\063\200\064\227\065\205\066\203\071\154\111\146" +
    "\112\206\113\217\126\165\127\151\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\070\003\153\005\257\006\043\010\247\011\244\064" +
    "\251\065\205\066\260\067\u01a2\070\322\071\154\111\146" +
    "\112\263\113\217\114\256\115\253\116\264\117\241\120" +
    "\266\121\246\122\242\123\261\124\255\125\323\126\250" +
    "\127\151\131\320\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\070\003\153\005\257\006\043" +
    "\010\247\011\244\064\251\065\205\066\260\067\u01a6\070" +
    "\322\071\154\111\146\112\263\113\217\114\256\115\253" +
    "\116\264\117\241\120\266\121\246\122\242\123\261\124" +
    "\255\125\323\126\250\127\151\131\320\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\146\u013f\154\235\174\234\001\001\000\002" +
    "\001\001\000\064\003\153\005\257\006\043\010\247\011" +
    "\244\064\251\065\205\066\260\071\154\111\146\112\263" +
    "\113\217\114\256\115\253\116\264\117\241\120\266\121" +
    "\246\122\242\123\261\124\255\125\323\126\250\127\151" +
    "\131\u01ad\001\001\000\002\001\001\000\040\153\u01af\154" +
    "\235\160\300\161\302\162\301\163\336\164\335\165\334" +
    "\166\332\167\330\170\333\171\331\172\327\173\326\174" +
    "\234\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\110\u01b3\001\001\000\062\003\153\005" +
    "\257\006\043\010\247\011\244\064\251\065\205\066\260" +
    "\071\154\111\146\112\263\113\217\114\256\115\253\116" +
    "\264\117\241\120\266\121\246\122\242\123\261\124\255" +
    "\125\u01b4\126\250\127\151\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\030\u01ba\001\001\000\002\001\001\000\076\003\153\004" +
    "\221\005\202\006\043\007\046\010\164\011\157\042\155" +
    "\044\u01bb\045\215\046\212\047\211\050\173\052\213\053" +
    "\163\054\214\055\145\056\150\057\216\061\207\063\200" +
    "\064\227\065\205\066\203\071\154\111\146\112\206\113" +
    "\217\126\165\127\151\001\001\000\002\001\001\000\010" +
    "\146\u013f\154\235\174\234\001\001\000\002\001\001\000" +
    "\002\001\001\000\076\003\153\004\221\005\202\006\043" +
    "\007\046\010\164\011\157\042\155\044\u01c0\045\215\046" +
    "\212\047\211\050\173\052\213\053\163\054\214\055\145" +
    "\056\150\057\216\061\207\063\200\064\227\065\205\066" +
    "\203\071\154\111\146\112\206\113\217\126\165\127\151" +
    "\001\001\000\002\001\001\000\012\145\u01c2\146\u013f\154" +
    "\235\174\234\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\134\u01c6\001\001\000\004\015" +
    "\u01c7\001\001\000\002\001\001\000\006\014\u01c9\017\006" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$mjavac$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$mjavac$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$mjavac$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	if(first) {	Type.initTypes();
			Env.initFirst();
	}
	if(second) Env.initSecond();

    }

 

  public static Scanner s;
  public static int errors = 0;
  public static int warnings = 0;
  public static boolean first = true, second = false;
  public static StringBuffer code = new StringBuffer();
  public static String objLoc = "null";

  public static void main(String argv[]) {

    for (int i = 0; i < argv.length; i++) {
      try { System.out.println("\n... Creating Symbol-Table for \""+argv[i]+"\" ...\n");
	  	s = new Scanner(new FileReader(argv[i]));
        	mjavac p = new mjavac(s);
        	p.parse();
        	System.out.println("Number of errors = " + errors + ".");
        	System.out.println("Number of warnings = " + warnings + ".");
		Type.printTypes();
	  	first = false;
	  	second = true;
        	System.out.println("\n... Generating intermediate code for \""+argv[i]+"\" ...\n");
		code.append("		; ModuleID = '"+argv[i]+".ll'\n\n");
		code.append("target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-s0:0:64-f80:32:32\"\n");
		code.append("target triple = \"i686-pc-linux-gnu\"\n\n");
		code.append("		; Global values\n");
		Set glob = Env.getGlobals().entrySet();
  		Iterator it = glob.iterator();
		while(it.hasNext()) { Map.Entry entry = (Map.Entry)it.next();
					    String key = (String)entry.getKey();
					    String value = (String)entry.getValue();
					    if (value.equals("struct")) code.append(key+"\n");
					    else { int lth = key.length() + 1;
						     code.append(value+" = internal constant ["+lth+" x i8] "+" c\""+key+"\\00\"\n");
					    }
		}
		code.append("\n");
		code.append("		; External declarations\n");
		code.append("declare i32 @printf(i8*, ...)\n");
		code.append("declare i32 @scanf(i8*, ...)\n\n");
        	s = new Scanner(new FileReader(argv[i]));
	  	p = new mjavac(s);
        	p.parse();
        	System.out.println("Number of errors = " + errors + ".");
        	System.out.println("Number of warnings = " + warnings + ".");
		Type.printTypes();
	  	if (errors == 0) try { FileOutputStream  fStream;
   					     PrintWriter  myStream;
   			      	     fStream = new FileOutputStream(argv[i]+".ll");
   					     myStream = new PrintWriter(fStream);
   					     myStream.println(code); 
   					     myStream.flush();
   					     myStream.close();
        				     System.out.println("\nCode written to \""+argv[i]+".ll\".");
				     }
				     catch (IOException e) { e.printStackTrace(System.out);
        			    				     System.exit(1);
      			     }
		else System.out.println("\nNo code produced.");
		System.out.println("--------------------------------------- (mjavac)");
      }
      catch (Exception e) { e.printStackTrace(System.out);
        			    System.exit(1);
      }
    }
  }
  
  public void report_error(String message, Object info) {
    if (info instanceof String){
	errors++; 
      System.err.println("  "+ errors + "==> " + info + " "+ message + 
					"\n       Parsing resumed from 2nd token before" + s.current_lexeme()+"\n");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
    }
  }

  public void sem_error(String lexeme, String message) {
	errors++;
     	System.err.println("Error "+ s.current_lexeme() + " : Semantic error");
      System.err.println("  "+ errors + "==> " + message + ": "+ lexeme + "\n");
  }

  public void warning(String lexeme, String message) {
	warnings++;
     	System.err.println("Warning "+ s.current_lexeme());
      System.err.println("  "+ warnings + "==> " + message + ": "+ lexeme + "\n");
  } 
  
  public void report_fatal_error(String message, Object info) {
    	report_error(message, info);
    	throw new RuntimeException("Fatal Syntax Error");
  }


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$mjavac$actions {



	class Sname {
	  public String name;
	  public Symb cs;
	  public Symb rs;

	  Sname(String n, Symb c, Symb r) {
		name = n;
		cs = c;
		rs = r;
	  }

	  public String toString(){
		return "Sname["+name+", "+cs+", "+rs+"]";
	  }
	}

	class Exp {
	  public Type type;
	  public String locT;
	  public String locN;
	  public Labels lab;

	  Exp(Type t, String lt, String ln) {
		type = t;
		locT = lt;
		locN = ln;
	  }

	  Exp(Type t, Labels l) {
		type = t;
		lab = l;
	  }

	  Exp(Type t, String lt, String ln, Labels l) {
		type = t;
		locT = lt;
		locN = ln;
		lab = l;
	  }

  	  public void load () {
		if(locN.startsWith("getelementptr")) { parser.code.append("	"+Tmp.nv()+" = "+locN+"\n");
								   locN = Tmp.lv();
		}
		if(locT.endsWith("*") && !locT.startsWith("%struct")) { parser.code.append("	"+Tmp.nv()+" = load "+locT+" "+locN+"\n");
					   	 					  locT = locT.replaceFirst("\\*", "");
					   	 					  locN = Tmp.lv();
		}
  	  }

  	  public String widen(Type w) {
		if(type == w) return locN;
 		if(type.isInteger() && w.isFloating()) parser.code.append("	"+Tmp.nv()+" = sitofp i32 "+locN+" to double\n");
 		if(type.isCharacter() && w.isFloating()) parser.code.append("	"+Tmp.nv()+" = sitofp i8 "+locN+" to double\n");
 		if(type.isCharacter() && w.isInteger()) parser.code.append("	"+Tmp.nv()+" = sext i8 "+locN+" to i32\n");
		return Tmp.lv();
  	  }

	}

	class ParamList {
	  public Type type;
	  public List list;

	  ParamList(Type t, List l) {
		type = t;
		list = l;
	  }
	}

	class Labels {
	  public String lBegin;
	  public String lTrue;
	  public String lFalse;
	  public String lNext;
	  public boolean bvalue;
	  public boolean bvDone;

	  Labels() {
		lBegin = Tmp.nl();
		lTrue = Tmp.nl();
		lFalse = Tmp.nl();
		lNext = Tmp.nl();
		bvalue = false;
		bvDone = false;
	  }
	}

	class Vars {
	  public Env e;
	  public List vl;

	  Vars(Env ee, List l) {
		e = ee;
		vl = l;
	  }
	}


  private final mjavac parser;

  /** Constructor */
  CUP$mjavac$actions(mjavac parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$mjavac$do_action(
    int                        CUP$mjavac$act_num,
    java_cup.runtime.lr_parser CUP$mjavac$parser,
    java.util.Stack            CUP$mjavac$stack,
    int                        CUP$mjavac$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$mjavac$result;

      /* select the action based on the action number */
      switch (CUP$mjavac$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // expression ::= assignment_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("expression",87, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // expression_opt ::= expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("expression_opt",86, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // expression_opt ::= 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("expression_opt",86, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // left_hand_side ::= array_access 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("left_hand_side",85, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // left_hand_side ::= field_access 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("left_hand_side",85, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // left_hand_side ::= name 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   		 			   	 RESULT = new Exp(Type.errortype(), "", "");
			   			     }
			   			     else { String locN = sn.cs.getLocN();
								if(locN.startsWith("getelementptr")) { String cn = Name.getCurrentClass().getName();
														   parser.code.append("		; left_hand_side\n");
														   locN = locN.replaceFirst("struct.+\\*", "struct."+cn+"*");
														   parser.code.append("	"+Tmp.nv()+" = "+locN+"\n");
														   locN = Tmp.lv();
					   	 								   RESULT = new Exp(sn.cs.getType(), sn.cs.getLocT(), Tmp.lv());
							      }
								else RESULT = new Exp(sn.cs.getType(), sn.cs.getLocT(), sn.cs.getLocN());
						     }

			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("left_hand_side",85, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // assignment ::= error NT$34 EQ assignment_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$34
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("assignment",84, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // NT$34 ::= 
            {
              Exp RESULT =null;
 parser.report_error("left_hand_side","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$34",122, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // assignment ::= left_hand_side EQ M14 assignment_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) if(e1.type.isArray()) { if(e1.type != e2.type) { parser.sem_error(""+e1.type+", "+e2.type, "INCOMPATIBLE TYPES");
				    						    	   			    RESULT = new Exp(Type.errortype(), "", "");
			   			   	  			   }
										   else { Symb s = Env.get(e1.locN.replaceFirst("%", ""));
											    s.putLocT(e2.locT);
											    s.putLocN(e2.locN);
										   }
						   }
						   else if(e1.type != e2.type) if(e1.type.isNumber() && e2.type.isNumber()) { Type t = Type.max(e1.type, e2.type);
															 				if(e2.type != t) { parser.code.append("		; assignment\n");
																						 e2.load();
									  						 							 String l2 = e2.widen(t);
							    	  														 parser.code.append("	store "+t.getCode()+" "+l2+", "+e1.locT+" "+e1.locN+"\n");
							    	  														 RESULT = new Exp(e1.type, e1.locT, e1.locN, l);
																			}
							  				 								else { parser.sem_error(""+e1.type+", "+e2.type, "LEFT-HAND TYPE SHORTER THAN RIGHT-END TYPE");
				    						    	   	  								 RESULT = new Exp(Type.errortype(), "", "");
			   			   	  				 								}
											 }
							  				 else { parser.sem_error(""+e1.type+", "+e2.type, "INCOMPATIBLE TYPES");
				    						    	   	  RESULT = new Exp(Type.errortype(), "", "");
			   			   	  				 }
			   			   	  else { parser.code.append("		; assignment\n");
							    	   if(e2.type.isBool() && !e2.lab.bvDone) { parser.code.append(e2.lab.lTrue+":	; l_True\n");
											   			   	  parser.code.append("	br label %"+e2.lab.lNext+"\n");
											   			   	  parser.code.append(e2.lab.lFalse+":	; l_False\n");
											   			  	  parser.code.append("	br label %"+e2.lab.lNext+"\n");
											   			  	  parser.code.append(e2.lab.lNext+":	; l_Next\n");
											  			   	  parser.code.append("	"+Tmp.nv()+" = phi i1 [true, %"+e2.lab.lTrue+"] ,[false, %"+e2.lab.lFalse+"]\n");
											   			   	  e2.locT = "i1";
											   			  	  e2.locN = Tmp.lv();
							    	   }
								   e2.load();
							    	   parser.code.append("	store "+e2.locT+" "+e2.locN+", "+e1.locT+" "+e1.locN+"\n");
							    	   RESULT = new Exp(e1.type, e1.locT, e1.locN, l);
						   	 }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("assignment",84, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // assignment_expression ::= assignment 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("assignment_expression",83, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // assignment_expression ::= conditional_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("assignment_expression",83, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // conditional_expression ::= error NT$33 QUESTION expression COLON conditional_or_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$33
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_expression",82, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // NT$33 ::= 
            {
              Exp RESULT =null;
 parser.report_error("conditional_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$33",121, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // conditional_expression ::= conditional_or_expression QUESTION M12 expression COLON M13 conditional_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e3 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isBool();
						     if(!b1) { parser.sem_error(""+e1.type, "NOT A BOOLEAN");
								   RESULT = new Exp(Type.errortype(), "", "");
						     }
			   			     else if(e2.type != e3.type) if(e2.type.isNumber() && e3.type.isNumber()) { e2.load();
							    											 	  e3.load();
									  									 	  Type t = Type.max(e2.type, e3.type);
									  									 	  String l2 = e2.widen(t);
									  									 	  String l3 = e3.widen(t);
												  							  parser.code.append("	br label %"+e1.lab.lNext+"\n");
						     						  							  parser.code.append(e1.lab.lNext+": 	; l_Next\n");
												  							  parser.code.append("	"+Tmp.nv()+" = phi "+t.getCode()+" ["+l2+", %"+e1.lab.lTrue+"] ,["+l3+", %"+e1.lab.lFalse+"]\n");
											       							  RESULT = new Exp(t, t.getCode(), Tmp.lv());
						     					   }
							    				   else { parser.sem_error(""+e2.type+", "+e3.type, "INCOMPATIBLE TYPES");
								     				    RESULT = new Exp(Type.errortype(), "", "");
						     	    				   }
				    		          else { e3.load();
								     parser.code.append("	br label %"+e1.lab.lNext+"\n");
						     		     parser.code.append(e1.lab.lNext+": 	; l_Next\n");
								     parser.code.append("	"+Tmp.nv()+" = phi "+e2.locT+" ["+e2.locN+", %"+e1.lab.lTrue+"] ,["+e3.locN+", %"+e1.lab.lFalse+"]\n");
								     RESULT = new Exp(e2.type, e2.type.getCode(), Tmp.lv());
						     	    }	   
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_expression",82, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // conditional_expression ::= conditional_or_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_expression",82, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // M13 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Exp e1 = (Exp)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
						     Exp e2 = (Exp)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
						     e2.load();
						     parser.code.append("	br label %"+e1.lab.lNext+"\n");
						     parser.code.append(e1.lab.lFalse+": 	; l_False\n");
						     RESULT = e1.lab;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M13",69, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // M12 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Exp e = (Exp)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
						     parser.code.append("		; conditional_expression\n");
						     if (e.lab.bvalue) { e.load();
										 parser.code.append("	br i1 "+e.locN+", label %"+e.lab.lTrue+", label %"+e.lab.lFalse+"\n");
						     }
						     parser.code.append(e.lab.lTrue+": 	; l_True\n");
						     RESULT = e.lab; 
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M12",68, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // conditional_or_expression ::= error NT$32 OROR conditional_and_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$32
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_or_expression",81, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // NT$32 ::= 
            {
              Exp RESULT =null;
 parser.report_error("conditional_or_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$32",120, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // conditional_or_expression ::= conditional_or_expression OROR M9 conditional_and_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isBool();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A BOOLEAN");
			   			     boolean b2 = e2.type.isBool();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A BOOLEAN");
				    		     if(b1 && b2) RESULT = e2;	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_or_expression",81, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // conditional_or_expression ::= conditional_and_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_or_expression",81, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // M9 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
						     parser.code.append("		; conditional_or_expression\n");
						     parser.code.append(l.lFalse+":	; l_False\n");
						     l.lFalse = Tmp.nl();
			   	    		     RESULT = l;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M9",65, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // conditional_and_expression ::= error NT$31 ANDAND equality_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$31
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_and_expression",80, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // NT$31 ::= 
            {
              Exp RESULT =null;
 parser.report_error("conditional_and_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$31",119, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // conditional_and_expression ::= conditional_and_expression ANDAND M8 equality_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isBool();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A BOOLEAN");
			   			     boolean b2 = e2.type.isBool();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A BOOLEAN");
				    		     if(b1 && b2) RESULT = e2;	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_and_expression",80, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // conditional_and_expression ::= equality_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("conditional_and_expression",80, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // M8 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
						     parser.code.append("		; conditional_and_expression\n");
						     parser.code.append(l.lTrue+":	; l_True\n");
						     l.lTrue = Tmp.nl();
			   	    		     RESULT = l;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M8",64, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // equality_expression ::= error NT$30 NOTEQ relational_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$30
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("equality_expression",79, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // NT$30 ::= 
            {
              Exp RESULT =null;
 parser.report_error("equality_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$30",118, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // equality_expression ::= error NT$29 EQEQ relational_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$29
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("equality_expression",79, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // NT$29 ::= 
            {
              Exp RESULT =null;
 parser.report_error("equality_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$29",117, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // equality_expression ::= equality_expression NOTEQ relational_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) if(e1.type != e2.type) if(e1.type.isNumber() && e2.type.isNumber()) { parser.code.append("		; equality_NOTEQ_expression\n");
							    											 Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
							    											 e1.load();
							    											 e2.load();
									  									 Type t = Type.max(e1.type, e2.type);
									  									 String l1 = e1.widen(t);
									  									 String l2 = e2.widen(t);
							    											 parser.code.append("	"+Tmp.nv()+" = icmp ne "+t.getCode()+" "+l1+", "+l2+"\n");
							    											 parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
							    											 RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
							  			  }
							  			  else { parser.sem_error(""+e1.type+", "+e2.type, "INCOMPATIBLE TYPES");
				    						    	   RESULT = new Exp(Type.errortype(), "", "");
			   			   	  			  }
 						   else { parser.code.append("		; equality_NOTEQ_expression\n");
							    Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
							    e1.load();
							    e2.load(); 
							    parser.code.append("	"+Tmp.nv()+" = icmp ne "+e1.locT+" "+e1.locN+", "+e2.locN+"\n");
							    parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
							    RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						   }	   
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("equality_expression",79, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // equality_expression ::= equality_expression EQEQ relational_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) if(e1.type != e2.type) if(e1.type.isNumber() && e2.type.isNumber()) { parser.code.append("		; equality_EQEQ_expression\n");
							    											 Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
							    											 e1.load();
							    											 e2.load();
									  									 Type t = Type.max(e1.type, e2.type);
									  									 String l1 = e1.widen(t);
									  									 String l2 = e2.widen(t);
							    											 parser.code.append("	"+Tmp.nv()+" = icmp eq "+t.getCode()+" "+l1+", "+l2+"\n");
							    											 parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
							    											 RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
							  			  }
							  			  else { parser.sem_error(""+e1.type+", "+e2.type, "INCOMPATIBLE TYPES");
				    						    	   RESULT = new Exp(Type.errortype(), "", "");
			   			   	  			  }
 						   else { parser.code.append("		; equality_EQEQ_expression\n");
							    Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
							    e1.load();
							    e2.load();
							    parser.code.append("	"+Tmp.nv()+" = icmp eq "+e1.locT+" "+e1.locN+", "+e2.locN+"\n");
							    parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
							    RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						   }	   	   
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("equality_expression",79, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // equality_expression ::= relational_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("equality_expression",79, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // relational_expression ::= error NT$28 GTEQ additive_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$28
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // NT$28 ::= 
            {
              Exp RESULT =null;
 parser.report_error("relational_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$28",116, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // relational_expression ::= error NT$27 LTEQ additive_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$27
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // NT$27 ::= 
            {
              Exp RESULT =null;
 parser.report_error("relational_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$27",115, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // relational_expression ::= error NT$26 GT additive_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$26
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // NT$26 ::= 
            {
              Exp RESULT =null;
 parser.report_error("relational_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$26",114, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // relational_expression ::= error NT$25 LT additive_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$25
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // NT$25 ::= 
            {
              Exp RESULT =null;
 parser.report_error("relational_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$25",113, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // relational_expression ::= relational_expression GTEQ additive_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; relational_GTEQ_expression\n");
									  Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
									  e1.load();
									  e2.load();
							  		  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+Tmp.nv()+" = icmp sge "+t.getCode()+" "+l1+", "+l2+"\n");
									  parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
									  RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						     }	   	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // relational_expression ::= relational_expression LTEQ additive_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; relational_LTEQ_expression\n");
									  Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
									  e1.load();
									  e2.load();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+Tmp.nv()+" = icmp sle "+t.getCode()+" "+l1+", "+l2+"\n");
									  parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
									  RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						     }	   	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // relational_expression ::= relational_expression GT additive_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; relational_GT_expression\n");
									  Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
									  e1.load();
									  e2.load();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+Tmp.nv()+" = icmp sgt "+t.getCode()+" "+l1+", "+l2+"\n");
									  parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
									  RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						     }	   	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // relational_expression ::= relational_expression LT additive_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; relational_LT_expression\n");
									  Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
									  e1.load();
									  e2.load();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+Tmp.nv()+" = icmp slt "+t.getCode()+" "+l1+", "+l2+"\n");
									  parser.code.append("	br i1 "+Tmp.lv()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
									  RESULT = new Exp(Type.bool(), "i1", Tmp.lv(), l);
						     }	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // relational_expression ::= additive_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("relational_expression",78, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // additive_expression ::= additive_expression MINUS multiplicative_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; additive_MINUS_expression\n");
									  e1.load();
									  e2.load();
									  String loc = ""+Tmp.nv();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+loc+" = sub "+t.getCode()+" "+l1+", "+l2+"\n");
									  RESULT = new Exp(t, t.getCode(), loc);
						     }	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("additive_expression",77, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // additive_expression ::= additive_expression PLUS multiplicative_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; additive_PLUS_expression\n");
									  e1.load();
									  e2.load();
									  String loc = ""+Tmp.nv();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+loc+" = add "+t.getCode()+" "+l1+", "+l2+"\n");
									  RESULT = new Exp(t, t.getCode(), loc);
						     }	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("additive_expression",77, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // additive_expression ::= multiplicative_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("additive_expression",77, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // multiplicative_expression ::= error NT$24 MOD unary_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$24
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // NT$24 ::= 
            {
              Exp RESULT =null;
 parser.report_error("multiplicative_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$24",112, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // multiplicative_expression ::= error NT$23 DIV unary_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$23
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // NT$23 ::= 
            {
              Exp RESULT =null;
 parser.report_error("multiplicative_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$23",111, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // multiplicative_expression ::= error NT$22 MULT unary_expression 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$22
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // NT$22 ::= 
            {
              Exp RESULT =null;
 parser.report_error("multiplicative_expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$22",110, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // multiplicative_expression ::= multiplicative_expression MOD unary_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isInteger();
						     if(!b1) parser.sem_error(""+e1.type, "NOT AN INTEGER");
			   			     boolean b2 = e2.type.isInteger();
						     if(!b2) parser.sem_error(""+e2.type, "NOT AN INTEGER");
				    		     if(b1 && b2) { parser.code.append("		; multiplicative_MOD_expression\n");
									  e1.load();
									  e2.load();
									  String loc = ""+Tmp.nv();
									  parser.code.append("	"+loc+" = srem i32 "+e1.locN+", "+e2.locN+"\n");					  
									  RESULT = new Exp(e1.type, "i32", loc);
						     }   	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // multiplicative_expression ::= multiplicative_expression DIV unary_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; multiplicative_DIV_expression\n");
									  e1.load();
									  e2.load();
									  String loc = ""+Tmp.nv();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  if(t.isFloating()) parser.code.append("	"+loc+" = fdiv "+t.getCode()+" "+l1+", "+l2+"\n");
									  else parser.code.append("	"+loc+" = sdiv "+t.getCode()+" "+l1+", "+l2+"\n");					  
									  RESULT = new Exp(t, t.getCode(), loc);
						     }   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // multiplicative_expression ::= multiplicative_expression MULT unary_expression 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { boolean b1 = e1.type.isNumber();
						     if(!b1) parser.sem_error(""+e1.type, "NOT A NUMBER");
			   			     boolean b2 = e2.type.isNumber();
						     if(!b2) parser.sem_error(""+e2.type, "NOT A NUMBER");
				    		     if(b1 && b2) { parser.code.append("		; multiplicative_MULT_expression\n");
									  e1.load();
									  e2.load();
									  String loc = ""+Tmp.nv();
									  Type t = Type.max(e1.type, e2.type);
									  String l1 = e1.widen(t);
									  String l2 = e2.widen(t);
									  parser.code.append("	"+loc+" = mul "+t.getCode()+" "+l1+", "+l2+"\n");						  
									  RESULT = new Exp(t, t.getCode(), loc);
						     }	   
			   			     else  RESULT = new Exp(Type.errortype(), "", "");
						   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // multiplicative_expression ::= unary_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("multiplicative_expression",76, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // unary_expression ::= MINUS unary_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { if(!e.type.isNumber()) { parser.sem_error(""+e.type, "NOT A NUMBER");
				    		   			     	    RESULT = new Exp(Type.errortype(), "", "");
						   }	   
			   			   parser.code.append("		; unary_minus_expression\n");
						   e.load();
						   String loc = ""+Tmp.nv();
						   parser.code.append("	"+loc+" = sub "+e.locT+" 0"+", "+e.locN+"\n");
						   Type t = e.type;
						   RESULT = new Exp(t, t.getCode(), loc);
			   }						    
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("unary_expression",75, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // unary_expression ::= PLUS unary_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) if(!e.type.isNumber()) { parser.sem_error(""+e.type, "NOT A NUMBER");
				    		   			     	    RESULT = new Exp(Type.errortype(), "", "");
						   }	   
			   			   else  RESULT = e;						    
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("unary_expression",75, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // unary_expression ::= NOT M10 unary_expression 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) if(!e.type.isBool()) { parser.sem_error(""+e.type, "NOT A BOOLEAN");
				    		   			   	  RESULT = new Exp(Type.errortype(), "", "");
						   }	   
			   			   else { String s = l.lTrue;
			   			     	    l.lTrue = l.lFalse;
			   			     	    l.lFalse = s;
 							    RESULT = new Exp(Type.bool(), l);
						   }						    
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("unary_expression",75, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // unary_expression ::= postfix_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("unary_expression",75, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // M10 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { parser.code.append("		; unary_NOT_expression\n");
			   			     RESULT = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M10",66, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // postfix_expression ::= AT name 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   		     RESULT = new Exp(Type.errortype(), "", "");
			   }
			   else RESULT = new Exp(Type.reference(sn.cs.getType()), sn.cs.getLocT(), sn.cs.getLocN()+"&"); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("postfix_expression",74, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // postfix_expression ::= name 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   		     RESULT = new Exp(Type.errortype(), "", "");
			   }
			   else { if((parser.second) && (sn.cs.getType() == Type.bool())) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;									    
											    	     		  if(!l.bvalue) parser.code.append("	br i1 "+sn.cs.getLocN()+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
											    	     		  RESULT = new Exp(Type.bool(), sn.cs.getLocT(), sn.cs.getLocN(), l);
			   	    }
				    else RESULT = new Exp(sn.cs.getType(), sn.cs.getLocT(), sn.cs.getLocN()); 
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("postfix_expression",74, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // postfix_expression ::= primary 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("postfix_expression",74, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // array_access ::= primary_no_new_array LBRACK expression RBRACK 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(!e2.type.isInteger()) { parser.sem_error(""+e2.type, "NOT AN INTEGER");
				    		            RESULT = new Exp(Type.errortype(), "", "");
			   } 
			   else RESULT = e1;
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_access",73, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // array_access ::= name LBRACK expression RBRACK 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) { if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   	      			   	 RESULT = new Exp(Type.errortype(), "", "");
			   			     }
			   			     else { Type t1 = sn.cs.getType();
				    				if(!t1.isArray()) { parser.sem_error(""+t1, "NOT AN ARRAY");
				    		 	   	    			  RESULT = new Exp(Type.errortype(), "", "");
			   	    				}
				   	    			else if(!e.type.isInteger()) { parser.sem_error(""+e.type, "NOT AN INTEGER");
				    		       	   		 			 RESULT = new Exp(Type.errortype(), "", "");
					  	   		     } 
					  	   		     else { parser.code.append("		; array_access\n");
										String locT = sn.cs.getLocT();
										String locN = sn.cs.getLocN();
										if(locT.endsWith("**")) { parser.code.append("	"+Tmp.nv()+" = load "+locT+" "+locN+"\n");
														  locT = locT.replaceFirst("\\*", "");
														  locN = Tmp.lv();
					   	 								  sn.cs.putLocT(locT);
					   	 								  sn.cs.putLocN(locN);
										}
										e.load();
										String index = Tmp.lv();
										if(locT.endsWith("]*")) parser.code.append("	"+Tmp.nv()+" = getelementptr "+locT+" "+locN+", i32 0, i32 "+index+"\n");
										else parser.code.append("	"+Tmp.nv()+" = getelementptr "+locT+" "+locN+", i32 "+index+"\n");
										Type t = ((Array)t1).getBase();
										RESULT = new Exp(t, t.getCode()+"*", Tmp.lv());
								     }
			   			     }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_access",73, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // method_invocation ::= SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN 
            {
              Exp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList e = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_invocation",72, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // method_invocation ::= primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int eLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList eL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) if(!e1.type.isReference()) { parser.sem_error(""+e1.type, "NOT A REFERENCE");
				    		 	   			   	  RESULT = new Exp(Type.errortype(), "", "");
			   			   }
			   			   else { Type name = ((Reference)e1.type).getReferred();
			   	   			    if (!name.isName()) { parser.sem_error(""+e1.type, "NOT A CLASS");
				    		       	 			  RESULT = new Exp(Type.errortype(), "", "");
			   	   			    }
			   	   			    else { Name c = (Name)name;
								     Symb sn = Env.get(n, c.getEnv()); 
			   			     		     if(sn == null) { parser.sem_error(n,"UNKNOWN NAME"); 
									       	    RESULT = new Exp(Type.errortype(), "", "");
								     }
			   			     		     else if (!sn.isPublic() && !Name.getCurrentClass().isSubclass(sn.getOwner())) { parser.sem_error(n, "ILLEGAL ACCESS TO PRIVATE ATTRIBUTE");
				    					 				     			     	      		  		 RESULT = new Exp(Type.errortype(), "", "");
						  	     		    }
						  	     		    else { String cName = c.getName(); 
										     ListIterator l = eL.list.listIterator();
								 		     parser.code.append("		; method_invocation\n");
										     parser.code.append("	"+Tmp.nv()+" = load "+e1.locT+" "+e1.locN+"\n");
										     String obj_ptr = Tmp.lv();
										     while (l.hasNext()) { Exp e = (Exp)l.next();
												   		   if(e.locT.contains("*")) if(e.locN.endsWith("&")) e.locN = e.locN.replace('&', ' ').trim(); 
											    				     	    		    else if(e.type.isArray()) { String t = ((Array)e.type).getBase().getCode()+"*";
																				   	  		  parser.code.append("	"+Tmp.nv()+" = bitcast "+e.locT+" "+e.locN+" to "+t+"\n");
 	    																			   	  		  e.locT = t;
																				   	  		  e.locN = Tmp.lv();
																    	   		   }
																    	   		   else if(!e.locT.startsWith("i8* getelementptr")) { if(e.locN.startsWith("getelementptr")) { parser.code.append("	"+Tmp.nv()+" = "+e.locN+"\n");
														   																		   	  		  e.locN = Tmp.lv();
																									    	   		   }
																									  	   		   parser.code.append("	"+Tmp.nv()+" = load "+e.locT+" "+e.locN+"\n");
																			         				     	  	   		   e.locT = e.locT.replaceFirst("\\*", "");
																								     	  	   		   e.locN = Tmp.lv();
											    						   	  	   }
								     		    } 
										    Type t1 = sn.getType();
				    				     		    if(!t1.isMethod()) { parser.sem_error(""+t1, "NOT A METHOD");
				    		             			   	  		 RESULT = new Exp(Type.errortype(), "", "");
			   	    				     		    }
								     		    else { Type t3 = ((Method)t1).getRange();
											     if(t3 == Type.voidtype()) parser.code.append("	call void @"+cName+"_"+n+"("); 
											     else parser.code.append("	"+Tmp.nv()+" = call "+t3.getCode()+" @"+cName+"_"+n+"(");
								     		    	     l = eL.list.listIterator();
								     		 	     parser.code.append("%struct."+cName+"* "+obj_ptr);											
								  			     while(l.hasNext()) { Exp e = (Exp)l.next();
											   			 	  parser.code.append(", "+e.locT+" "+e.locN);
								 			     }
								 		  	     Type t5 = ((Method)t1).getDomain();
										 	     if(t5 != eL.type) { parser.sem_error(""+t5+", "+eL.type, "INCOMPATIBLE ARGUMENT IN METHOD INVOCATION "+n);
				    				             	  				 RESULT = new Exp(Type.errortype(), "", "");
			   	  	   						     }
											     else { parser.code.append(")\n");
											  	      Labels lab = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
									 	  	   	      RESULT = new Exp(t3, t3.getCode(), Tmp.lv(), lab);
								     		  	     }
										    }
									   }								     
			   			          }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_invocation",72, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // method_invocation ::= name LPAREN argument_list_opt RPAREN 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int eLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList eL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second)
					  parse: { if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   	      			   	 RESULT = new Exp(Type.errortype(), "", "");
			   			     }
			   			     else { Name c = sn.cs.getOwner();
								String cName = null;
								if(c != null) cName = c.getName(); 
								ListIterator l = eL.list.listIterator();
								parser.code.append("		; method_invocation\n");
								while (l.hasNext()) { Exp e = (Exp)l.next();
											    if(e.locT.contains("*")) if(e.locN.endsWith("&")) e.locN = e.locN.replace('&', ' ').trim(); 
											    				     else if(e.type.isArray()) { String t = ((Array)e.type).getBase().getCode()+"*";
																				   parser.code.append("	"+Tmp.nv()+" = bitcast "+e.locT+" "+e.locN+" to "+t+"\n");
 	    																			   e.locT = t;
																				   e.locN = Tmp.lv();
																    }
																    else if(!e.locT.startsWith("i8* getelementptr")) { if(e.locN.startsWith("getelementptr")) { parser.code.append("	"+Tmp.nv()+" = "+e.locN+"\n");
														   																		   e.locN = Tmp.lv();
																									    }
																									  parser.code.append("	"+Tmp.nv()+" = load "+e.locT+" "+e.locN+"\n");
																			         				     	  e.locT = e.locT.replaceFirst("\\*", "");
																								     	  e.locN = Tmp.lv();
											    						   }
								}
								if(sn.name.equals("printf")) parser.code.append("	"+Tmp.nv()+" = call i32 (i8*, ...)* @printf(");
						   		else if(sn.name.equals("scanf")) parser.code.append("	"+Tmp.nv()+" = call i32 (i8*, ...)* @scanf(");
							  	     else { Type t1 = sn.cs.getType();
				    						if(!t1.isMethod()) { parser.sem_error(""+t1, "NOT A METHOD");
				    		             			   		   RESULT = new Exp(Type.errortype(), "", "");
													   break parse;
			   	    						}
										else { Type t3 = ((Method)t1).getRange();
											 if(t3 == Type.voidtype()) parser.code.append("	call void @"+cName+"_"+sn.name+"("); 
											 else parser.code.append("	"+Tmp.nv()+" = call "+t3.getCode()+" @"+cName+"_"+sn.name+"(");
 										}
								     }
								l = eL.list.listIterator();
								if(sn.name.equals("scanf") || sn.name.equals("printf")) { Exp e = (Exp)l.next();
											   						    parser.code.append(e.locT+" "+e.locN);
								}
								else { if(sn.cs == Env.get(sn.name)) if(Method.getCurrentName().equals("main")) parser.objLoc = "null";
														 else parser.objLoc = "%this";
									 parser.code.append("%struct."+cName+"* "+parser.objLoc);
								}											
								while(l.hasNext()) { Exp e = (Exp)l.next();
											   parser.code.append(", "+e.locT+" "+e.locN);
								}
			   	    				if(sn.name.equals("printf")||sn.name.equals("scanf")){ parser.code.append(")\n");
																	 RESULT = new Exp(Type.integer(), "", "");										  	 						 
								}
 								else { 
									 Type t1 = sn.cs.getType();
									 Type t5 = ((Method)t1).getDomain();
									 if(t5 != eL.type) { parser.sem_error(""+t5+", "+eL.type, "INCOMPATIBLE ARGUMENT IN METHOD INVOCATION "+sn.name);
				    				             	  	   RESULT = new Exp(Type.errortype(), "", "");
			   	  	   				 }
					   				 else { parser.code.append(")\n");
										  Type t4 = ((Method)t1).getRange();
										  Labels lab = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
									 	  RESULT = new Exp(t4, t4.getCode(), Tmp.lv(), lab);
									 }
								}
			   			     }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_invocation",72, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // field_access ::= SUPER DOT IDENTIFIER 
            {
              Exp RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { Name c = Name.getCurrentClass();
						     String sn = c.getSuper();						     
 			   			     if(sn == null){ parser.sem_error(""+c,"NOT A SUBCLASS");
				    	     				   RESULT = new Exp(Type.errortype(), "", "");
			   			     }
						     else {	Symb ss = Env.get(sn);
								Name sc = (Name)ss.getType();
						    		Symb s = Env.get(n, sc.getEnv());
			   			     		if(s == null){ parser.sem_error(n,"UNKNOWN NAME");
				    	     				  	   RESULT = new Exp(Type.errortype(), "", "");
			   			     		} 
				  			      else RESULT = new Exp(s.getType(), "", "");
						     }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("field_access",71, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // field_access ::= primary DOT IDENTIFIER 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { if(!e.type.isReference()) { parser.sem_error(""+e.type, "NOT A REFERENCE");
				    					 	    	   RESULT = new Exp(Type.errortype(), "", "");
						     }
				  		     else { Type r = ((Reference)e.type).getReferred();
								if(!r.isName()) { parser.sem_error(""+r, "NOT A CLASS");
				    					 	      RESULT = new Exp(Type.errortype(), "", "");
						     		}
								else { Symb s = Env.get(n, ((Name)r).getEnv()); 
			   			     			 if(s == null){ parser.sem_error(n,"UNKNOWN NAME");
				    	     				  		    RESULT = new Exp(Type.errortype(), "", "");
			   			     			 } 
			   			     			 else if(!s.isPublic() && !Name.getCurrentClass().isSubclass(s.getOwner())) { parser.sem_error(n, "ILLEGAL ACCESS TO PRIVATE FIELD");
				    					 				     	     				 	     			RESULT = new Exp(Type.errortype(), "", "");
						  	    			}
				  			    			else RESULT = new Exp(s.getType(), "", "");
						     		}								
						     }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("field_access",71, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // dims ::= dims LBRACK RBRACK 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dims",59, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // dims ::= LBRACK RBRACK 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dims",59, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // dims_opt ::= dims 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dims_opt",58, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // dims_opt ::= 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dims_opt",58, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // dim_expr ::= LBRACK expression RBRACK 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dim_expr",57, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // dim_exprs ::= error NT$21 dim_expr 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$21
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dim_exprs",56, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // NT$21 ::= 
            {
              Exp RESULT =null;
 parser.report_error("dim_expr","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$21",109, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // dim_exprs ::= dim_exprs dim_expr 
            {
              Exp RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e1 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e1; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dim_exprs",56, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // dim_exprs ::= dim_expr 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("dim_exprs",56, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // array_creation_expression ::= NEW name dim_exprs dims_opt 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) if(!e2.type.isInteger()) { parser.sem_error(""+e2.type, "NOT AN INTEGER");
				    			 			 	RESULT = new Exp(Type.errortype(), "", "");
		   	   			   }
			   			   else { if(sn.cs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   			 			  	RESULT = new Exp(Type.errortype(), "", "");
			   	    			    }
			   	    			    else try { int s = Integer.parseInt(e2.locN);
									   Type t1 = Type.reference(sn.cs.getType());
								  	   parser.code.append("		; array_creation\n");									
  								  	   parser.code.append("	"+Tmp.nv()+" = malloc ["+e2.locN+" x "+t1.getCode()+"]\n");
								  	   Type t = Type.array(s, t1);
								  	   String c = "["+s+" x "+t1.getCode()+"]*";
							    	  	   RESULT = new Exp(t, c, Tmp.lv());
						   	  	   }
							  	   catch (Exception e) { parser.sem_error(""+e2.locN, "NOT AN INTEGER_LITERAL");
				    			 			 		 RESULT = new Exp(Type.errortype(), "", "");
							  	   }
			   			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_creation_expression",55, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // array_creation_expression ::= NEW primitive_type dim_exprs dims_opt 
            {
              Exp RESULT =null;
		int t1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Type t1 = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e2 = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) if(!e2.type.isInteger()) { parser.sem_error(""+e2.type, "NOT AN INTEGER");
				    			 			 	RESULT = new Exp(Type.errortype(), "", "");
		   				   }
			   			   else try { int s = Integer.parseInt(e2.locN);
								  parser.code.append("		; array_creation\n");									
  								  parser.code.append("	"+Tmp.nv()+" = malloc ["+e2.locN+" x "+t1.getCode()+"]\n");
								  Type t = Type.array(s, t1);
								  String c = "["+s+" x "+t1.getCode()+"]*";
							    	  RESULT = new Exp(t, c, Tmp.lv());
						   	  }
							  catch (Exception e) { parser.sem_error(""+e2.locN, "NOT AN INTEGER_LITERAL");
				    			 			 	RESULT = new Exp(Type.errortype(), "", "");
							  }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_creation_expression",55, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // argument_list ::= error NT$20 expression 
            {
              ParamList RESULT =null;
              // propagate RESULT from NT$20
                RESULT = (ParamList) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("argument_list",54, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // NT$20 ::= 
            {
              ParamList RESULT =null;
 parser.report_error("argument_list","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$20",108, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // argument_list ::= argument_list COMMA expression 
            {
              ParamList RESULT =null;
		int eLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int eLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		ParamList eL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { eL.list.add(e);
			   			     eL.type = Type.product(eL.type, e.type);
			   			     RESULT = eL;
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("argument_list",54, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // argument_list ::= expression 
            {
              ParamList RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) { List l = new ArrayList();
			   			     l.add(e);
			   			     RESULT = new ParamList(e.type, l);
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("argument_list",54, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // argument_list_opt ::= argument_list 
            {
              ParamList RESULT =null;
		int eLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		ParamList eL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.second) RESULT = eL; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("argument_list_opt",53, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // argument_list_opt ::= 
            {
              ParamList RESULT =null;
		 if(parser.second) RESULT = new ParamList(Type.voidtype(), new ArrayList()); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("argument_list_opt",53, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // class_body_opt ::= class_body 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_opt",12, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // class_body_opt ::= 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_opt",12, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // class_instance_creation_expression ::= NEW name NT$19 LPAREN argument_list_opt RPAREN class_body_opt 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$19
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		ParamList e2 = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		 if(parser.second) { if(sn.rs == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				   		     			       RESULT = new Exp(Type.errortype(), "", "");
			   			     }
			   			     else { String objptr = Tmp.lv();
								ListIterator l = e2.list.listIterator();
								parser.code.append("		; constructor_invocation\n");
								while (l.hasNext()) { Exp e = (Exp)l.next();
											    if(e.locT.contains("*")) if(e.locN.endsWith("&")) e.locN = e.locN.replace('&', ' ').trim(); 
											    				     else if(e.type.isArray()) { String t = ((Array)e.type).getBase().getCode()+"*";
																				   parser.code.append("	"+Tmp.nv()+" = bitcast "+e.locT+" "+e.locN+" to "+t+"\n");
 	    																			   e.locT = t;
																				   e.locN = Tmp.lv();
																    }
																    else if(!e.locT.startsWith("i8* getelementptr")) { parser.code.append("	"+Tmp.nv()+" = load "+e.locT+" "+e.locN+"\n");
																			         				     	    e.locT = e.locT.replaceFirst("\\*", "");
																								     	    e.locN = Tmp.lv();
											    						   }
								}
								Type t = sn.rs.getType();
				    		     		if (!t.isName()) { parser.sem_error(""+t, "NOT A CLASS");
				    		           				 RESULT = new Exp(Type.errortype(), "", "");
			   	    		     		}
			   	    		     		else { Env e = ((Name)t).getEnv();
			   	    	     		      	 Symb s1 = Env.get(sn.name, e);
					     				 Type t1 = s1.getType();
			   	    	     				 if(!t1.isConstructor()) { parser.sem_error(""+t1, "NOT A CONSTRUCTOR");
				    			    	     		 		  	   RESULT = new Exp(Type.errortype(), "", "");
			   	    	     			       }
			          	     				 else if(((Constructor)t1).getDomain() != e2.type) { parser.sem_error(""+e2.type, "INCOMPATIBLE ARGUMENT IN CONSTRUCTOR INVOCATION "+sn.name);
				    					 				  		     	    RESULT = new Exp(Type.errortype(), "", "");
			   	  	   	    		     		}
					   	    		            else if(!s1.isPublic() && !Name.getCurrentClass().isSubclass(sn.rs.getOwner())) { parser.sem_error(sn.name, "ILLEGAL ACCESS TO PRIVATE CONSTRUCTOR");
				    					 				     			     	      			          RESULT = new Exp(Type.errortype(), "", "");
						  	   		    	     }
						  	   		    	     else { parser.code.append("	call void @"+sn.name+"("+"%struct."+sn.name+"* "+objptr);
										     		l = e2.list.listIterator();
										     		while(l.hasNext()) { Exp pe = (Exp)l.next();
											    		 	 	   parser.code.append(", "+pe.locT+" "+pe.locN);
										     		}
										     		parser.code.append(")\n");
												RESULT = new Exp(((Constructor)t1).getRange(), "%struct."+sn.name+"*", objptr);
									    	    }
			 	    		     		     }
			   			     }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_instance_creation_expression",52, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // NT$19 ::= 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 if(parser.second) if(sn.rs != null) { Type t = sn.rs.getType();
				    					     if(t.isName()) { Env e = ((Name)t).getEnv();
			   	    	     		      				    Symb s1 = Env.get(sn.name, e);
					     							    Type t1 = s1.getType();
			   	    	     							    if(t1.isConstructor()) { parser.code.append("		; class_instance_creation_expression\n");																 
																     parser.code.append("	"+Tmp.nv()+" = malloc %struct."+sn.name+"\n");																     
												    } 
									     }
									   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$19",107, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // primary_no_new_array ::= error NT$18 DOT THIS 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$18
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // NT$18 ::= 
            {
              Exp RESULT =null;
 parser.report_error("primary_no_new_array","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$18",106, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // primary_no_new_array ::= LPAREN M11 error NT$17 RPAREN 
            {
              Exp RESULT =null;
              // propagate RESULT from NT$17
                RESULT = (Exp) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // NT$17 ::= 
            {
              Exp RESULT =null;
 parser.report_error("primary_no_new_array","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$17",105, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // primary_no_new_array ::= name DOT THIS 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // primary_no_new_array ::= name DOT CLASS 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // primary_no_new_array ::= array_type DOT CLASS 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // primary_no_new_array ::= VOID DOT CLASS 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // primary_no_new_array ::= primitive_type DOT CLASS 
            {
              Exp RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // primary_no_new_array ::= array_access 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // primary_no_new_array ::= method_invocation 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if((parser.second) && (e.type == Type.bool())) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;									    
											    if(!l.bvalue) parser.code.append("	br i1 "+e.locN+", label %"+l.lTrue+", label %"+l.lFalse+"\n");
											    l.bvDone = true;
											    RESULT = new Exp(Type.bool(), e.locT, e.locN, l);
			   }
			   else RESULT = e; 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // primary_no_new_array ::= field_access 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // primary_no_new_array ::= class_instance_creation_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // primary_no_new_array ::= LPAREN M11 expression RPAREN 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if((parser.second) && (e.type == Type.bool()) && (l!= null)) RESULT = new Exp(Type.bool(), e.locT, e.locN, l);
			   else RESULT = e; 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // primary_no_new_array ::= THIS 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Type.reference(Name.getCurrentClass()), "", ""); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // primary_no_new_array ::= literal 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if((parser.second) && (e.type == Type.bool())) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;									    
											    if(!l.bvalue) if (e.locN.equals("true")) parser.code.append("	br label %"+l.lTrue+"\n");
											    			else parser.code.append("	br label %"+l.lFalse+"\n"); 
											    RESULT = new Exp(Type.bool(), e.locT, e.locN, l);
			   }
			   else RESULT = e; 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary_no_new_array",51, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // M11 ::= 
            {
              Labels RESULT =null;
		 if (parser.second) RESULT = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M11",67, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // primary ::= array_creation_expression 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary",50, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // primary ::= primary_no_new_array 
            {
              Exp RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = e; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primary",50, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // return_statement ::= RETURN M14 expression_opt SEMICOLON 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) { Type r = Method.getCurrent().getRange();
						     if(e.type != r) if(e.type.isNumber() && r.isNumber()) { Type mt = Type.max(e.type, r);
																 String t = mt.getCode();
															 	 if(e.type != mt) { parser.code.append("		; return_statement\n");
																			  e.load();
									  						 				  String l = e.widen(mt);
																			  parser.code.append("	store "+t+" "+l+", "+t+"*"+" %tmp\n");
																			  parser.code.append("	"+Tmp.nv()+" = load "+t+"*"+" %tmp\n");
																			  parser.code.append("	store "+t+" "+Tmp.lv()+", "+t+"*"+" %retval\n");
																			  parser.code.append("	br label %return\n");
																 }
							  				 					 else  parser.sem_error(""+r+", "+e.type, "RANGE TYPE SHORTER THAN RETURNED TYPE");
									   }
							  		   else  parser.sem_error(""+r+", "+e.type, "INCOMPATIBLE TYPES");
						     else { String t = e.type.getCode();
								parser.code.append("		; return_statement\n");
								e.load();
								parser.code.append("	store "+e.locT+" "+e.locN+", "+t+"*"+" %tmp\n");
								parser.code.append("	"+Tmp.nv()+" = load "+t+"*"+" %tmp\n");
								parser.code.append("	store "+t+" "+Tmp.lv()+", "+t+"*"+" %retval\n");
								parser.code.append("	br label %return\n");	
						     }
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("return_statement",49, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // M14 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = new Labels();
						     l.bvalue = true;
						     RESULT = l;
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M14",70, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // while_statement_no_short_if ::= WHILE LPAREN M7 expression M5 RPAREN statement_no_short_if 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		 if(parser.second) if(!e.type.isBool()) parser.sem_error(""+e.type, "NOT A BOOLEAN");
						   else { parser.code.append("	br label %"+l.lBegin+"\n");
							    parser.code.append(l.lFalse+":	; lFalse\n");
						   }	
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("while_statement_no_short_if",48, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // while_statement ::= WHILE error NT$16 M5 RPAREN statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("while_statement",47, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // NT$16 ::= 
            {
              Object RESULT =null;
 parser.report_error("expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$16",104, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // while_statement ::= WHILE LPAREN M7 expression M5 RPAREN statement 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		 if(parser.second) if(!e.type.isBool()) parser.sem_error(""+e.type, "NOT A BOOLEAN");
						   else { parser.code.append("	br label %"+l.lBegin+"\n");
							    parser.code.append(l.lFalse+":	; l_False\n");
						   }	
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("while_statement",47, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // if_then_else_statement_no_short_if ::= IF LPAREN M4 expression M5 RPAREN statement_no_short_if M6 ELSE statement_no_short_if 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		 if(parser.second) if(!e.type.isBool()) parser.sem_error(""+e.type, "NOT A BOOLEAN");
						   else { parser.code.append("	br label %"+l.lNext+"\n");
							    parser.code.append(l.lNext+":	; l_Next\n");
						   }	
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("if_then_else_statement_no_short_if",46, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-9)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // if_then_else_statement ::= IF LPAREN M4 error NT$15 M5 RPAREN statement_no_short_if ELSE statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("if_then_else_statement",45, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-9)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // NT$15 ::= 
            {
              Object RESULT =null;
 parser.report_error("expression","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$15",103, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // if_then_else_statement ::= IF LPAREN M4 expression M5 RPAREN statement_no_short_if M6 ELSE statement 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-7)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		 if(parser.second) if(!e.type.isBool()) parser.sem_error(""+e.type, "NOT A BOOLEAN");
						   else { parser.code.append("	br label %"+l.lNext+"\n");
							    parser.code.append(l.lNext+":	; l_Next\n");
						   }	
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("if_then_else_statement",45, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-9)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // if_then_statement ::= IF error NT$14 M5 RPAREN statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("if_then_statement",44, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // NT$14 ::= 
            {
              Object RESULT =null;
 parser.report_error("if_then_statement","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$14",102, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // if_then_statement ::= IF LPAREN M4 expression M5 RPAREN statement 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		Labels l = (Labels)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).right;
		Exp e = (Exp)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		 if(parser.second) if(!e.type.isBool()) parser.sem_error(""+e.type, "NOT A BOOLEAN");
						   else { parser.code.append("	br label %"+l.lFalse+"\n");
							    parser.code.append(l.lFalse+":	; l_False\n");
						   }	
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("if_then_statement",44, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // M7 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = new Labels();
			    			     parser.code.append("	br label %"+l.lBegin+"\n");
			    			     parser.code.append(l.lBegin+":	; l_Begin\n");
						     RESULT = l;
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M7",63, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // M6 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
			    			     parser.code.append("	br label %"+l.lNext+"\n");
			    			     parser.code.append(l.lFalse+":	; l_False\n");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M6",62, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // M5 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) { Labels l = (Labels)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
			    			     parser.code.append(l.lTrue+":	; l_True\n");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M5",61, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // M4 ::= 
            {
              Labels RESULT =null;
		 if(parser.second) RESULT = new Labels(); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M4",60, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // statement_expression ::= class_instance_creation_expression 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_expression",43, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // statement_expression ::= method_invocation 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_expression",43, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // statement_expression ::= assignment 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_expression",43, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expression_statement ::= statement_expression SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("expression_statement",42, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // empty_statement ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("empty_statement",41, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // statement_without_trailing_substatement ::= return_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_without_trailing_substatement",40, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // statement_without_trailing_substatement ::= expression_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_without_trailing_substatement",40, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // statement_without_trailing_substatement ::= empty_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_without_trailing_substatement",40, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // statement_without_trailing_substatement ::= block 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_without_trailing_substatement",40, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // statement_no_short_if ::= while_statement_no_short_if 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_no_short_if",39, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // statement_no_short_if ::= if_then_else_statement_no_short_if 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_no_short_if",39, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // statement_no_short_if ::= statement_without_trailing_substatement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement_no_short_if",39, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // statement ::= while_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement",38, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // statement ::= if_then_else_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement",38, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // statement ::= if_then_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement",38, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // statement ::= statement_without_trailing_substatement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("statement",38, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // local_variable_declaration_statement ::= type error NT$13 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("local_variable_declaration_statement",37, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // NT$13 ::= 
            {
              Object RESULT =null;
 parser.report_error("local_variable_declaration_statement","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$13",101, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // local_variable_declaration_statement ::= type variable_declarators SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("local_variable_declaration_statement",37, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // block_statement ::= statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statement",36, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // block_statement ::= local_variable_declaration_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statement",36, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // block_statements ::= error NT$12 block_statement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statements",35, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // NT$12 ::= 
            {
              Object RESULT =null;
 parser.report_error("block_statements","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$12",100, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // block_statements ::= block_statements block_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statements",35, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // block_statements ::= block_statement 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statements",35, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // block_statements_opt ::= block_statements 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statements_opt",34, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // block_statements_opt ::= 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block_statements_opt",34, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // block ::= LBRACE M2 error NT$11 RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block",32, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // NT$11 ::= 
            {
              Object RESULT =null;
 parser.report_error("block","WRONG");
			   System.out.println(" BLOCK EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();
 			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$11",99, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // block ::= LBRACE M2 block_statements_opt RBRACE 
            {
              Object RESULT =null;
		 System.out.println(" BLOCK EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("block",32, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // explicit_constructor_invocation ::= primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("explicit_constructor_invocation",31, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // explicit_constructor_invocation ::= primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("explicit_constructor_invocation",31, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // explicit_constructor_invocation ::= SUPER LPAREN argument_list_opt RPAREN SEMICOLON 
            {
              Object RESULT =null;
		int e2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		ParamList e2 = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		 if(parser.second) { Name c = Name.getCurrentClass();
						     String sup = c.getSuper();
						     if(sup == null){ parser.sem_error(c.getName(), "NOT HAVING A SUPERCLASS");
				   		     			    RESULT = new Exp(Type.errortype(), "", "");
			   			     }
						     else { Name sc = Env.get(sup).getOwner();
								Env se = sc.getEnv();
								Symb ss = Env.get(sup, se);
								if(ss == null) { parser.sem_error(sup, "NOT HAVING A CONSTRUCTOR");
				   		     			           RESULT = new Exp(Type.errortype(), "", "");
			   			     		}
								else { Type t1 = ss.getType();
			   	    	     				 if(!t1.isConstructor()) { parser.sem_error(""+t1, "NOT A CONSTRUCTOR");
				    			    	     		 		  	   RESULT = new Exp(Type.errortype(), "", "");
			   	    	     			       } 
									 else { parser.code.append("		; explicit_constructor_invocation_SUPER\n");
										  ListIterator l = e2.list.listIterator();
										  while (l.hasNext()) { Exp e = (Exp)l.next();
											    			if(e.locT.contains("*")) if(e.locN.endsWith("&")) e.locN = e.locN.replace('&', ' ').trim(); 
											    				     			 else if(e.type.isArray()) { String t = ((Array)e.type).getBase().getCode()+"*";
																				   		     parser.code.append("	"+Tmp.nv()+" = bitcast "+e.locT+" "+e.locN+" to "+t+"\n");
 	    																			   		     e.locT = t;
																				    		     e.locN = Tmp.lv();
																    			}
																    			else if(!e.locT.startsWith("i8* getelementptr")) { parser.code.append("	"+Tmp.nv()+" = load "+e.locT+" "+e.locN+"\n");
																			         				     	      		e.locT = e.locT.replaceFirst("\\*", "");
																								     	      		e.locN = Tmp.lv();
											    								     }
										  }
			          	     				 	  if(((Constructor)t1).getDomain() != e2.type) { parser.sem_error(""+e2.type, "INCOMPATIBLE ARGUMENT IN CONSTRUCTOR INVOCATION "+sup);
				    					 				  		     	    		 RESULT = new Exp(Type.errortype(), "", "");
			   	  	   	    		     		  }
					   	    		              else { parser.code.append("	"+Tmp.nv()+" = bitcast %struct."+c.getName()+"* %this to %struct."+sup+"*\n");
											   parser.code.append("	call void @"+sup+"("+"%struct."+sup+"* "+Tmp.lv());
										     	   l = e2.list.listIterator();
										     	   while(l.hasNext()) { Exp pe = (Exp)l.next();
											    		 	 	parser.code.append(", "+pe.locT+" "+pe.locN);
										     	   }
										     	   parser.code.append(")\n");
											   RESULT = new Exp(((Constructor)t1).getRange(), "%struct."+sup+"*", Tmp.lv());
									    	  }
			 	    		     		      }
			   			           }
						    }
			   }
			   else RESULT = new Exp(Type.voidtype(), "", "");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("explicit_constructor_invocation",31, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // explicit_constructor_invocation ::= THIS LPAREN argument_list_opt RPAREN SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("explicit_constructor_invocation",31, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // M2 ::= 
            {
              Object RESULT =null;
		 System.out.println(" BLOCK ENTRY");
			   if(parser.first) Env.push(); 
			   if(parser.second) { Env.next();
						     ListIterator l = Env.getVars().listIterator();
						     if(l.hasNext()) parser.code.append("		; M2\n");
						     while(l.hasNext()) { String p = (String)l.next();
										  Symb s = Env.get(p);
			   			     				  Type t = s.getType();						     				 
										  String tc = s.getType().getCode();										  
						     				  parser.code.append("	%"+p+" = alloca "+tc+"\n");						     				  
										  s.putLocT(tc+"*");
										  s.putLocN("%"+p);
						     }
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M2",33, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // constructor_body ::= LBRACE M3 error RBRACE 
            {
              Object RESULT =null;
		 parser.report_error("block","WRONG");
			   System.out.println(" CONSTRUCTOR EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();  
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("constructor_body",30, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // constructor_body ::= LBRACE M3 block_statements_opt RBRACE 
            {
              Object RESULT =null;
		 System.out.println(" CONSTRUCTOR EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("constructor_body",30, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // constructor_body ::= LBRACE M3 explicit_constructor_invocation block_statements_opt RBRACE 
            {
              Object RESULT =null;
		 System.out.println(" CONSTRUCTOR EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("constructor_body",30, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // constructor_declarator ::= modifiers_opt IDENTIFIER NT$10 LPAREN formal_parameter_list_opt RPAREN 
            {
              Type RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Type) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int pLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int pLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList pL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.first) { Name c = Name.getCurrentClass();
			   			    String cname = c.getName();
			   			    Symb csymb = Env.get(cname);
			   			    Symb s;
			   			    if(csymb.isPublic()) s = new Symb(Type.constructor(pL.type, Type.reference(Type.getName(n))), c, m.booleanValue());
			   			    else { if(m.booleanValue()) parser.warning(n, "PUBLIC CONSTRUCTOR DECLARED IN PRIVATE CLASS");
				    		           s = new Symb(Type.constructor(pL.type, Type.reference(Type.getName(n))), c, false);
			   			    }	
			   			    Env.putSymb(n, s);
			   }
			   if(parser.second) { Symb msymb = Env.get(n);
						     Constructor c = (Constructor)msymb.getType();
						     Constructor.putCurrent(n, c);
						     Type t2 = c.getRange();
						     String ptrt = "%struct."+n+"*";
						     parser.code.append(ptrt+" %this");
						     ListIterator l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
									        Symb s = Env.get(p);
						                       	  Type t = s.getType();
									        if(t.isArray()) { String tc = ((Array)t).getBase().getCode()+"*";
												        parser.code.append(", "+tc+" "+s.getLocN());
													  s.putLocT(tc);
									        }
									        else parser.code.append(", "+s.getLoc());
						     } 
						     parser.code.append(") {\nentry:\n");
						     l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
										  Symb s = Env.get(p);
										  Type t = s.getType();
			   			     				  String tc;
										  if(t.isArray()) tc = s.getLocT();
										  else tc = t.getCode();
						     				  parser.code.append("	%"+p+"_addr = alloca "+tc+"\n");
						     				  parser.code.append("	store "+s.getLoc()+", "+tc+"* %"+p+"_addr\n");
										  s.putLocT(tc+"*");
										  s.putLocN("%"+p+"_addr");
						     }
						     RESULT = t2;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("constructor_declarator",29, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // NT$10 ::= 
            {
              Type RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 if(parser.first) { if (!Env.put(n, null)) parser.sem_error(n,"DUPLICATE NAME");
						    else { Name c = Name.getCurrentClass();
			   			    	     String cname = c.getName();
						    	     if (!n.equals(cname)) parser.sem_error(n+", "+cname,"CONSTRUCTOR NAME DIFFERENT FROM CLASS NAME");
						    }
						    System.out.println(" CONSTRUCTOR ENTRY: "+n);
		 				    Env.push();
			   }
			   if(parser.second) { System.out.println(" CONSTRUCTOR ENTRY: "+n);
						     Env.next();
						     Symb msymb = Env.get(n);
						     Constructor c = (Constructor)msymb.getType();
						     parser.code.append("		; constructor_declarator\n");
						     parser.code.append("define "+Type.voidtype().getCode()+" @"+n+"(");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$10",98, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // constructor_declaration ::= constructor_declarator constructor_body 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) { parser.code.append("		; constructor_declaration\n");
					       parser.code.append("	br label %return\n");
					       parser.code.append("return:\n");
					       parser.code.append("	ret void\n");
					       parser.code.append("}\n\n");
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("constructor_declaration",28, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // M3 ::= 
            {
              Object RESULT =null;
		 if(parser.second) { ListIterator l = Env.getVars().listIterator();
						     if(l.hasNext())parser.code.append("		; M3\n");
						     while(l.hasNext()) { String p = (String)l.next();
										  Symb s = Env.get(p);
			   			     				  Type t = s.getType();
										  if(!t.isArray()) { String tc = s.getType().getCode();										  
						     				  			   parser.code.append("	%"+p+" = alloca "+tc+"\n");						     				  
										  			   s.putLocT(tc+"*");
										  			   s.putLocN("%"+p);
										  }
						     }
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M3",22, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // method_body ::= SEMICOLON 
            {
              Object RESULT =null;
		 System.out.println(" METHOD EXIT");
			   if(parser.first) Env.pop();
			   if(parser.second) Env.next(); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_body",27, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // method_body ::= LBRACE M3 error RBRACE 
            {
              Object RESULT =null;
		 parser.report_error("block","WRONG");
			   System.out.println(" METHOD EXIT");
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_body",27, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // method_body ::= LBRACE M3 block_statements_opt RBRACE 
            {
              Object RESULT =null;
		 System.out.println(" METHOD EXIT");
			   if(parser.first) Env.pop(); 
			   if(parser.second) Env.next();
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_body",27, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // formal_parameter ::= type variable_declarator_id 
            {
              String RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.first) Env.remVar(n);
			   RESULT = n; 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter",26, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // formal_parameter_list ::= error NT$9 formal_parameter 
            {
              ParamList RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (ParamList) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",25, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$9 ::= 
            {
              ParamList RESULT =null;
 parser.report_error("formal_parameter_list","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$9",97, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // formal_parameter_list ::= formal_parameter_list COMMA formal_parameter 
            {
              ParamList RESULT =null;
		int pLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int pLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		ParamList pL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 pL.list.add(n);
			   pL.type = Type.product(pL.type, Env.get(n).getType());
			   RESULT = pL; 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",25, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // formal_parameter_list ::= formal_parameter 
            {
              ParamList RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 List l = new ArrayList();
			   l.add(n);
			   RESULT = new ParamList(Env.get(n).getType(), l); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",25, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // formal_parameter_list_opt ::= formal_parameter_list 
            {
              ParamList RESULT =null;
		int pLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int pLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		ParamList pL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = pL; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter_list_opt",24, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // formal_parameter_list_opt ::= 
            {
              ParamList RESULT =null;
		 RESULT = new ParamList(Type.voidtype(), new ArrayList()); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("formal_parameter_list_opt",24, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // method_header ::= error NT$8 LPAREN formal_parameter_list_opt RPAREN 
            {
              Type RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Type) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_header",23, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$8 ::= 
            {
              Type RESULT =null;
 parser.report_error("method_header","WRONG");
			   Env.push();
 			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$8",96, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // method_header ::= modifiers_opt VOID IDENTIFIER NT$7 LPAREN formal_parameter_list_opt RPAREN 
            {
              Type RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Type) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int pLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int pLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList pL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.first) { Name c = Name.getCurrentClass();
			   			    String cname = c.getName();
			   			    Symb csymb = Env.get(cname);
			   			    Symb s;
			   			    if(csymb.isPublic()) s = new Symb(Type.method(pL.type, Type.voidtype()), c, m.booleanValue());
			   			    else { if(m.booleanValue()) parser.warning(n, "PUBLIC METHOD DECLARED IN PRIVATE CLASS");
				    		           s = new Symb(Type.method(pL.type, Type.voidtype()), c, false);
			   			    }
			   			    Env.putSymb(n, s);
			   }
			   if(parser.second) { Symb msymb = Env.get(n);
						     Method.putCurrent(n, (Method)msymb.getType());
						     String ptrt = "%struct."+Name.getCurrentClass().getName()+"*";
						     if(!n.equals("main")) parser.code.append(ptrt+" %this");
						     ListIterator l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
									        Symb s = Env.get(p);
						                       	  Type t = s.getType();
									        if(t.isArray()) { String tc = ((Array)t).getBase().getCode()+"*";
												        parser.code.append(", "+tc+" "+s.getLocN());
													  s.putLocT(tc);
									        }
									        else parser.code.append(", "+s.getLoc());
						     }  
						     parser.code.append(") {\nentry:\n");
						     l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
										  Symb s = Env.get(p);
										  Type t = s.getType();
			   			     				  String tc;
										  if(t.isArray()) tc = s.getLocT();
										  else tc = t.getCode();
						     				  parser.code.append("	%"+p+"_addr = alloca "+tc+"\n");
						     				  parser.code.append("	store "+s.getLoc()+", "+tc+"* %"+p+"_addr\n");
										  s.putLocT(tc+"*");
										  s.putLocN("%"+p+"_addr");
						     }
						     RESULT = Type.voidtype();
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_header",23, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$7 ::= 
            {
              Type RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 if(parser.first) { if (!Env.put(n, null)) parser.sem_error(n,"DUPLICATE NAME");
						    System.out.println(" METHOD ENTRY: "+n);
		 				    Env.push();
			   }
			   if(parser.second) { System.out.println(" METHOD ENTRY: "+n);
						     Env.next();
						     parser.code.append("		; method_header\n");
						     if(n.equals("main")) parser.code.append("define void @main(");
					           else parser.code.append("define "+Type.voidtype().getCode()+" @"+Name.getCurrentClass().getName()+"_"+n+"(");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$7",95, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // method_header ::= modifiers_opt type IDENTIFIER NT$6 LPAREN formal_parameter_list_opt RPAREN 
            {
              Type RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Type) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).right;
		Type t1 = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-5)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int pLleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int pLright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		ParamList pL = (ParamList)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.first) { Name c = Name.getCurrentClass();
			   			    String cname = c.getName();
			   			    Symb csymb = Env.get(cname);
			   			    Symb s;
			   			    if(csymb.isPublic()) s = new Symb(Type.method(pL.type, t1), c, m.booleanValue());
			   			    else { if(m.booleanValue()) parser.warning(n, "PUBLIC METHOD DECLARED IN PRIVATE CLASS");
				    		           s = new Symb(Type.method(pL.type, t1), c, false);
			   			    }
			   			    Env.putSymb(n, s); 
			   }
			   if(parser.second) { Name c = Name.getCurrentClass();
						     Symb msymb = Env.get(n, c.getEnv());
						     Method.putCurrent(n, (Method)msymb.getType());
						     String ptrt = "%struct."+c.getName()+"*";
						     parser.code.append(ptrt+" %this");
						     ListIterator l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
									        Symb s = Env.get(p);
						                       	  Type t = s.getType();
									        if(t.isArray()) { String tc = ((Array)t).getBase().getCode()+"*";
												        parser.code.append(", "+tc+" "+s.getLocN());
													  s.putLocT(tc);
									        }
									        else parser.code.append(", "+s.getLoc());
						     } 
						     parser.code.append(") {\nentry:\n");
						     l = pL.list.listIterator();
						     while(l.hasNext()) { String p = (String)l.next();
										  Symb s = Env.get(p);
										  Type t = s.getType();
			   			     				  String tc;
										  if(t.isArray()) tc = s.getLocT();
										  else tc = t.getCode();
						     				  parser.code.append("	%"+p+"_addr = alloca "+tc+"\n");
						     				  parser.code.append("	store "+s.getLoc()+", "+tc+"* %"+p+"_addr\n");
										  s.putLocT(tc+"*");
										  s.putLocN("%"+p+"_addr");
						     }
						     parser.code.append("	%retval = alloca "+t1.getCode()+"\n");
						     parser.code.append("	%tmp = alloca "+t1.getCode()+"\n");
						     RESULT = t1;
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_header",23, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // NT$6 ::= 
            {
              Type RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int t1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int t1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Type t1 = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 if(parser.first) { if (!Env.put(n, null)) parser.sem_error(n,"DUPLICATE NAME");
						    System.out.println(" METHOD ENTRY: "+n);
		 			          Env.push();
			   }
			   if(parser.second) { System.out.println(" METHOD ENTRY: "+n);
						     Env.next();
						     parser.code.append("		; method_header\n");
						     parser.code.append("define "+t1.getCode()+" @"+Name.getCurrentClass().getName()+"_"+n+"(");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$6",94, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // method_declaration ::= method_header method_body 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 if(parser.second) { parser.code.append("		; method_declaration\n");
						     parser.code.append("	br label %return\n");
						     parser.code.append("return:\n");
						     if(t == Type.voidtype()) parser.code.append("	ret void\n"); 
						     else { parser.code.append("	"+Tmp.nv()+" = load "+t.getCode()+"* %retval\n");
						     	    parser.code.append("	ret "+t.getCode()+" "+Tmp.lv()+"\n");
						     }
						     parser.code.append("}\n\n");
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("method_declaration",21, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // variable_declarator_id ::= variable_declarator_id LBRACK RBRACK 
            {
              String RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("variable_declarator_id",20, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // variable_declarator_id ::= IDENTIFIER 
            {
              String RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 if(parser.first) { Boolean m = (Boolean)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
			   			    boolean mod = m == null ? false: m.booleanValue();	
			  			    Type t = (Type)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
			   			    Name c = Name.getCurrentClass();
			   			    String cname = c.getName();
			   			    Symb csymb = Env.get(cname);
			   			    Symb s;
			   			    if(csymb.isPublic()) s = new Symb(t, c, mod, t.getCode(), "%"+n);
			   			    else { if(mod) parser.warning(n, "PUBLIC FIELD DECLARED IN PRIVATE CLASS");
				    			     s = new Symb(t, c, false, t.getCode(), "%"+n);
			   			    }
			   			    if (!Env.putVar(n, s)) parser.sem_error(n,"DUPLICATE NAME");						    	
			   }
			   RESULT = n;
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("variable_declarator_id",20, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // M1 ::= 
            {
              Type RESULT =null;
		 RESULT = (Type)((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("M1",8, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // variable_declarators ::= error NT$5 COMMA variable_declarator_id 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("variable_declarators",19, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.report_error("variable_declarator_id","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$5",93, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // variable_declarators ::= variable_declarators COMMA M1 variable_declarator_id 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("variable_declarators",19, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // variable_declarators ::= variable_declarator_id 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("variable_declarators",19, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // field_declaration ::= modifiers_opt type error NT$4 method_declaration 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("field_declaration",18, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // NT$4 ::= 
            {
              Object RESULT =null;
 parser.report_error("field_declaration","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$4",92, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // field_declaration ::= modifiers_opt type error NT$3 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("field_declaration",18, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // NT$3 ::= 
            {
              Object RESULT =null;
 parser.report_error("variable_declarators","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$3",91, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // field_declaration ::= modifiers_opt type variable_declarators SEMICOLON 
            {
              Object RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("field_declaration",18, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-3)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // class_member_declaration ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_member_declaration",17, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // class_member_declaration ::= method_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_member_declaration",17, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // class_member_declaration ::= field_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_member_declaration",17, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // class_body_declaration ::= block 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declaration",16, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // class_body_declaration ::= constructor_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declaration",16, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // class_body_declaration ::= class_member_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declaration",16, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // class_body_declarations ::= class_body_declarations class_body_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declarations",14, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // class_body_declarations ::= class_body_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declarations",14, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // class_body_declarations_opt ::= class_body_declarations 
            {
              Object RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int wright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declarations_opt",15, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // class_body_declarations_opt ::= 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body_declarations_opt",15, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // class_body ::= LBRACE class_body_declarations_opt RBRACE 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_body",11, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // class_declaration ::= modifiers_opt CLASS IDENTIFIER EXTENDS IDENTIFIER NT$2 class_body 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)).value;
		int n1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int n1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		java.lang.String n1 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int n2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int n2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		java.lang.String n2 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		 System.out.println("CLASS EXIT: "+n1);
			   if(parser.first) { List e_vars = new ArrayList();
						    Env e = Env.getCurrent();
						    e_vars.add(new Vars(e, e.getEvars()));
 						    Name cl = Env.get(n1).getOwner();
						    String sup = cl.getSuper();
						    while(sup != null){ cl = Env.get(sup).getOwner();
										e = cl.getEnv();
						    				e_vars.add(0, new Vars(e, e.getEvars()));
										sup = cl.getSuper();
						    }					    
					          ListIterator evl = e_vars.listIterator();
						    int n = 0;
						    String global = "%struct."+n1+" = type { ";
						    boolean first = true;
						    while(evl.hasNext()){ Vars ev = (Vars)evl.next();
										  ListIterator l = ev.vl.listIterator();										  
						    				  while(l.hasNext()){ String v = (String)l.next();
									    				    Symb s = Env.get(v, ev.e);
									    				    String c = s.getType().getCode();
									    				    s.putLocT(c + "*");
									    				    s.putLocN("getelementptr %struct."+n1+"* %this, i32 0, i32 "+n);
									    				    n++;
									    				    if(first) { global = global + c;
															    first = false;
													    }
													    else global = global + ", " + c;
										  }
						    }
						    global = global + " }";
						    Env.putGlobal(global, "struct");
						    Env.get(n1).putLocT(global.replace("%struct."+n1+" = ",""));
						    Env.pop();
						    Env.pop();
			   }
			   if(parser.second) { Env.next();
						     Env.next();
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_declaration",10, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-6)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$2 ::= 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int n1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int n1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		java.lang.String n1 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int n2left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int n2right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n2 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 System.out.println("CLASS ENTRY: "+n1);
			   if(parser.first) switch (Env.putClass(n1, m.booleanValue(),n2)){ case 1: parser.sem_error(n1,"DUPLICATE CLASS NAME");
							     								    break;
													        case 2: parser.sem_error(n2,"UNKNOWN CLASS");
					        }
  			   if(parser.second) { Env.next();
						     Env.next();
						     Name c = Env.get(n1).getOwner();
						     Name.putCurrentClass(c);
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$2",90, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // class_declaration ::= modifiers_opt CLASS IDENTIFIER NT$1 class_body 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)).value;
		int n1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int n1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		java.lang.String n1 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		 System.out.println("CLASS EXIT: "+n1);
			   if(parser.first) { Env e = Env.getCurrent();
						    List vars = e.getEvars();
					          ListIterator l = vars.listIterator();
						    int n = 0;
						    String global = "%struct."+n1+" = type { ";
						    boolean first = true;
						    while(l.hasNext()) { String v = (String)l.next();
									    	 Symb s = Env.get(v);
									   	 String c = s.getType().getCode();
									   	 s.putLocT(c + "*");
									  	 s.putLocN("getelementptr %struct."+n1+"* %this, i32 0, i32 "+n);
									   	 n++;
									    	 if(first) { global = global + c;
											       first = false;
									   	 }
									   	 else global = global + ", " + c;
						    }
						    global = global + " }";
						    Env.putGlobal(global, "struct");
						    Env.get(n1).putLocT(global.replace("%struct."+n1+" = ",""));	    				
						    Env.pop();
						  }
			   if(parser.second) Env.next();
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_declaration",10, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-4)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$1 ::= 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Boolean m = (Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int n1left = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int n1right = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n1 = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
 System.out.println("CLASS ENTRY: "+n1);
			   if(parser.first) if (Env.putClass(n1, m.booleanValue()) != 0) parser.sem_error(n1,"DUPLICATE CLASS NAME");
 			   if(parser.second) { Env.next();
						     Name c = Env.get(n1).getOwner();
						     Name.putCurrentClass(c);
			   } 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$1",89, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // class_declarations ::= error NT$0 class_declaration 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_declarations",9, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NT$0 ::= 
            {
              Object RESULT =null;
 parser.report_error("class_declaration","WRONG"); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("NT$0",88, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // class_declarations ::= class_declarations class_declaration 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_declarations",9, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // class_declarations ::= 
            {
              Object RESULT =null;

              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("class_declarations",9, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // modifiers_opt ::= PUBLIC 
            {
              Boolean RESULT =null;
		 RESULT = Boolean.valueOf(true); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("modifiers_opt",13, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // modifiers_opt ::= 
            {
              Boolean RESULT =null;
		 RESULT = Boolean.valueOf(false); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("modifiers_opt",13, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // name ::= name DOT IDENTIFIER 
            {
              Sname RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 Symb s1 = sn.cs;
			   if(s1 == null) { parser.sem_error(sn.name, "UNKNOWN NAME");
						  RESULT = new Sname(n, null, null);
			   }
			   else { Type t1 = s1.getType();
				    if(!t1.isReference()) { parser.sem_error(""+t1, "NOT A REFERENCE");
								    RESULT = new Sname(n, null, null);
				    }
				    else { Type r = ((Reference)t1).getReferred();
					     if(!r.isName()) { parser.sem_error(""+r, "NOT A CLASS");
								     RESULT = new Sname(n, null, null);
					     }
					     else { Symb s2 = Env.get(n, ((Name)r).getEnv()); 
			   			     	if(s2 == null) { parser.sem_error(n,"UNKNOWN NAME"); 
									     RESULT = new Sname(n, null, null);
							}
			   			     	else if (!s2.isPublic() && !Name.getCurrentClass().isSubclass(s2.getOwner())) { parser.sem_error(n, "ILLEGAL ACCESS TO PRIVATE ATTRIBUTE");
				    					 				     			     	      		  RESULT = new Sname(n, null, null);
						  	     }
						  	     else { if(parser.second) { parser.code.append("		; name\n");
												  parser.code.append("	"+Tmp.nv()+" = load "+s1.getLoc()+"\n");
												  parser.objLoc = Tmp.lv();
									}
									RESULT = new Sname(n, s2, Env.get(n, Env.getRoot()));
							     }
					     }								
				    }
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("name",7, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-2)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // name ::= IDENTIFIER 
            {
              Sname RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String n = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = new Sname(n, Env.get(n), Env.get(n, Env.getRoot())); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("name",7, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // array_type ::= name dims 
            {
              Type RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 Symb s = sn.cs; 
			   if(s == null) { parser.sem_error(sn.name,"UNKNOWN NAME");
				    		 RESULT = Type.errortype();
			   } 
			   else RESULT = Type.array(0, Type.reference(s.getType()));
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_type",6, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // array_type ::= primitive_type dims 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		 RESULT = Type.array(0, t); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("array_type",6, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // reference_type ::= array_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = t; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("reference_type",5, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // reference_type ::= name 
            {
              Type RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int snright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Sname sn = (Sname)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 Symb s = sn.rs; 
			   if(s == null) RESULT = Type.reference(Type.forwardName(sn.name, parser.s.current_lexeme())); 
			   else RESULT = Type.reference(s.getType());
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("reference_type",5, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // numeric_type ::= FLOAT 
            {
              Type RESULT =null;
		 RESULT = Type.floating(); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("numeric_type",4, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // numeric_type ::= CHAR 
            {
              Type RESULT =null;
		 RESULT = Type.character(); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("numeric_type",4, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // numeric_type ::= INT 
            {
              Type RESULT =null;
		 RESULT = Type.integer(); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("numeric_type",4, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // primitive_type ::= BOOLEAN 
            {
              Type RESULT =null;
		 RESULT = Type.bool(); 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primitive_type",3, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // primitive_type ::= numeric_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = t; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("primitive_type",3, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // type ::= reference_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = t; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("type",2, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // type ::= primitive_type 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 RESULT = t; 
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("type",2, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // literal ::= NULL_LITERAL 
            {
              Exp RESULT =null;
		 
			   RESULT = new Exp(Type.reference(Type.voidtype()), "", "null"); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // literal ::= STRING_LITERAL 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.String l = (java.lang.String)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 
			   if(parser.first) Env.putGlobal(l , Tmp.ns());
			   if(parser.second) { int i = l.length() + 1;
			   			     String ary = "["+i+" x i8]";
			   			     String tmp = Env.getGlobal(l);
			   			     String loc = "i8* getelementptr ("+ary+"* "+tmp+", i32 0, i32 0)";
			   			     Symb s = Env.get("String", Env.getRoot());
			   			     if(s == null) RESULT = new Exp(Type.reference(Type.forwardName("String", parser.s.current_lexeme())), loc, ""); 
			   			     else RESULT = new Exp(Type.reference(s.getType()), loc, ""); 
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // literal ::= CHARACTER_LITERAL 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.Character l = (java.lang.Character)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 
			   RESULT = new Exp(Type.character(), "i8", ""+l); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // literal ::= BOOLEAN_LITERAL 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.Boolean l = (java.lang.Boolean)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 
			   RESULT = new Exp(Type.bool(), "i1", ""+l); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // literal ::= FLOATING_POINT_LITERAL 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.Number l = (java.lang.Number)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 
			   RESULT = new Exp(Type.floating(), "double", ""+l); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // literal ::= INTEGER_LITERAL 
            {
              Exp RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()).right;
		java.lang.Number l = (java.lang.Number)((java_cup.runtime.Symbol) CUP$mjavac$stack.peek()).value;
		 
			   RESULT = new Exp(Type.integer(), "i32", ""+l); 
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("literal",1, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // goal ::= class_declarations 
            {
              Object RESULT =null;
		 Hashtable forwards;
			   if(parser.first) { forwards = Name.ForwardHashtable();
						    int err = forwards.size();
						    if(err > 0) { parser.errors = parser.errors + err;
     						    	     		System.err.println("Error : Semantic error");
      					    	     		System.err.println("  ==> CANNOT FIND CLASSES ("+err+"): "+forwards+"\n");
						    }
			   }
			
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          return CUP$mjavac$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)).value;
		RESULT = start_val;
              CUP$mjavac$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$mjavac$stack.elementAt(CUP$mjavac$top-1)), ((java_cup.runtime.Symbol)CUP$mjavac$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$mjavac$parser.done_parsing();
          return CUP$mjavac$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

